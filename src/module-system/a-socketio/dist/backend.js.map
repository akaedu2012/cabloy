{"version":3,"file":"backend.js","mappings":";;;;;;AAAA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB,GAAG,QAAQ,GAAG,KAAK;AAC9D;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB,GAAG,QAAQ,GAAG,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,qBAAqB;AAC3D;AACA,2BAA2B,UAAU,EAAE,IAAI,GAAG,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA,2CAA2C,sCAAsC;AACjF;;AAEA;AACA,qBAAqB,sCAAsC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,gCAAgC;AACnE,gDAAgD,mBAAmB;AACnE;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,sCAAsC;AAC/D;AACA;AACA;AACA;AACA,2DAA2D,sCAAsC;AACjG;AACA,oCAAoC,oDAAoD;AACxF;;AAEA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,sCAAsC;AAC/D;AACA;AACA;AACA;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE,UAAU;AACV;AACA;AACA;AACA,uCAAuC,mDAAmD;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,aAAa;AAC5E,gBAAgB;AAChB;AACA;AACA;AACA,6CAA6C,mDAAmD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,yDAAyD;AACxF;AACA;AACA,yDAAyD,yDAAyD;AAClH;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,0DAA0D,yDAAyD;AACnH,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,4BAA4B;AACrE;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;;AAEA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,oDAAoD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,QAAQ;AACR;AACA,oCAAoC,8CAA8C;AAClF;AACA;;AAEA;AACA,0BAA0B,oDAAoD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA,+CAA+C,iEAAiE;AAChH;AACA;AACA,YAAY;AACZ;AACA,2CAA2C,mDAAmD;AAC9F;AACA,SAAS;AACT,OAAO;AACP;;AAEA,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA,2BAA2B,8CAA8C;AACzE;AACA,uDAAuD,8CAA8C;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA,sBAAsB,8CAA8C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF,SAAS;AACT,OAAO;AACP;;AAEA,iBAAiB,6CAA6C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6CAA6C;AAC9F;AACA;AACA;AACA;AACA,8CAA8C,8DAA8D;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,8CAA8C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,8CAA8C;AAC5F;;AAEA,yBAAyB,6CAA6C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6CAA6C;AACzF;;AAEA,yBAAyB,8DAA8D;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sDAAsD;AAC1G;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,2BAA2B;AACvD;AACA,iCAAiC,eAAe,GAAG,aAAa;AAChE;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA,8BAA8B,wBAAwB,cAAc,sBAAsB;AAC1F;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,6BAA6B,cAAc,2BAA2B;AAChG,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;;AAEA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA,2BAA2B,UAAU,MAAM,gBAAgB,KAAK,KAAK;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA,+CAA+C,mDAAmD;AAClG;AACA;AACA;AACA,kCAAkC,6DAA6D;AAC/F;;AAEA;AACA;AACA;AACA,iBAAiB,yDAAyD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0CAA0C;AACtF;AACA;AACA,qCAAqC,0CAA0C;AAC/E;;AAEA,4BAA4B,0CAA0C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB,GAAG,OAAO,GAAG,KAAK;AAC9D;AACA,sCAAsC;AACtC;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;;AAEA;AACA,uBAAuB,0CAA0C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB,GAAG,OAAO,GAAG,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC,OAAO;AACP;;AAEA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;;;;;;;ACztBA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;;;;;;;ACrBA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;;AAEA,sBAAsB,oDAAoD;AAC1E,gDAAgD,oDAAoD;AACpG;;AAEA,wBAAwB,sCAAsC;AAC9D,8CAA8C,sCAAsC;AACpF;;AAEA,8BAA8B,yDAAyD;AACvF,oDAAoD,yDAAyD;AAC7G;;AAEA,0BAA0B,mDAAmD;AAC7E;AACA;;AAEA,uBAAuB,mDAAmD;AAC1E,0CAA0C,mDAAmD;AAC7F;;AAEA,yBAAyB,mDAAmD;AAC5E;AACA;AACA;;AAEA,mBAAmB,6CAA6C;AAChE,sCAAsC,6CAA6C;AACnF;;AAEA,uBAAuB,kDAAkD;AACzE;AACA;AACA;;AAEA,+BAA+B,8DAA8D;AAC7F;AACA;;AAEA,sBAAsB,sCAAsC;AAC5D,0CAA0C,sCAAsC;AAChF;;AAEA,sBAAsB,qCAAqC;AAC3D,kDAAkD,qCAAqC;AACvF;;AAEA;AACA;AACA;AACA,gBAAgB,8CAA8C,GAAG,8CAA8C;AAC/G;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe;AACf;;AAEA,mBAAmB,6BAA6B;AAChD,gCAAgC,uCAAuC;AACvE;;AAEA,kBAAkB,6BAA6B;AAC/C,uCAAuC,uCAAuC;AAC9E,eAAe;AACf;;AAEA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qCAAqC;AAClF;AACA;AACA,mCAAmC,qCAAqC;AACxE;;AAEA,qBAAqB,qCAAqC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,kBAAkB,oCAAoC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gDAAgD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3MA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,8BAA8B;AAC5D;AACA,4CAA4C,0BAA0B;AACtE;AACA;;AAEA,gBAAgB,8BAA8B;AAC9C,0BAA0B,KAAK,IAAI;AACnC;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B,oEAAoE,0BAA0B;AAC9F,aAAa;AACb,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA,0BAA0B,0BAA0B;AACpD;AACA,qDAAqD,0BAA0B;AAC/E;AACA;AACA,+CAA+C,0BAA0B;AACzE,yDAAyD,OAAO,GAAG,kBAAkB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjJA;AACA;AACA,qBAAqB,yCAAyC;AAC9D;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD,QAAQ;AACR;AACA;;AAEA;AACA,6BAA6B,eAAe;AAC5C,YAAY;AACZ;AACA,yDAAyD;AACzD,eAAe;AACf;AACA,YAAY;AACZ,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA,cAAc,8CAA8C;AAC5D;AACA;;AAEA;AACA;AACA,sBAAsB,KAAK,aAAa,QAAQ,oBAAoB,YAAY;AAChF;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,sBAAsB,KAAK,aAAa,QAAQ,qBAAqB;AACrE;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,yBAAyB;AACtC;;AAEA;AACA;AACA,sBAAsB,KAAK,aAAa,QAAQ,oBAAoB,YAAY;AAChF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACjFA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4CAA4C;AACxF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,sCAAsC;AACjF;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;;AAEA;AACA;AACA,oDAAoD,qBAAqB;AACzE;;AAEA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA,4CAA4C,4CAA4C;AACxF;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC,yCAAyC,QAAQ,WAAW,SAAS;AACrE;AACA;AACA,4CAA4C,QAAQ,WAAW,SAAS;AACxE;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA,cAAc,qDAAqD;AACnE,oDAAoD,oDAAoD;AACxG;AACA;;AAEA;AACA;;;;;;;;ACTA;AACA;AACA;AACA,cAAc,uCAAuC;AACrD,mDAAmD,sCAAsC;AACzF;AACA;;AAEA;AACA;;;;;;;;ACTA;AACA;AACA;AACA,cAAc,+CAA+C;AAC7D,gDAAgD,8CAA8C;AAC9F;AACA;;AAEA;AACA;;;;;;;;ACTA;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C,sDAAsD,2BAA2B;AACjF;AACA;;AAEA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;;;;;AC9FA,uBAAuB,mBAAO,CAAC,GAA2B;AAC1D,qBAAqB,mBAAO,CAAC,GAAyB;AACtD,0BAA0B,mBAAO,CAAC,EAA8B;AAChE,uBAAuB,mBAAO,CAAC,GAA2B;AAC1D,2BAA2B,mBAAO,CAAC,EAA+B;AAClE,4BAA4B,mBAAO,CAAC,GAAgC;AACpE,qBAAqB,mBAAO,CAAC,GAAyB;AACtD,sBAAsB,mBAAO,CAAC,GAA0B;AACxD,kBAAkB,mBAAO,CAAC,GAAsB;AAChD,wBAAwB,mBAAO,CAAC,EAA4B;AAC5D,6BAA6B,mBAAO,CAAC,GAAiC;AACtE,yBAAyB,mBAAO,CAAC,GAA6B;AAC9D,eAAe,mBAAO,CAAC,EAAmB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;AC7EA;AACA;AACA,sBAAsB,sDAAsD;AAC5E;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;ACvDA;AACA;;;;;;;;ACDA;;;;;;;;ACAA;AACA,WAAW,mBAAO,CAAC,EAAmB;AACtC;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;ACRA;AACA;AACA;AACA;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;ACVA,WAAW,mBAAO,CAAC,GAAoB;AACvC,qBAAqB,mBAAO,CAAC,GAA8B;AAC3D,gBAAgB,mBAAO,CAAC,GAAyB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACXA,eAAe,mBAAO,CAAC,EAAoB;AAC3C,gBAAgB,mBAAO,CAAC,EAAqB;AAC7C,eAAe,mBAAO,CAAC,GAAoB;AAC3C,wBAAwB,mBAAO,CAAC,EAA+B;AAC/D,wBAAwB,mBAAO,CAAC,GAA2B;;AAE3D;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAO,CAAC,GAAY;AACpC;AACA,iBAAiB,mBAAO,CAAC,GAAa;AACtC;AACA,sBAAsB,mBAAO,CAAC,EAAkB;AAChD;AACA,mBAAmB,mBAAO,CAAC,GAAe;AAC1C;AACA,iBAAiB,mBAAO,CAAC,GAAa;AACtC;AACA,eAAe,mBAAO,CAAC,GAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AACA,kBAAkB,mBAAO,CAAC,GAAgC;AAC1D;AACA,gCAAgC,mBAAO,CAAC,GAAoC;AAC5E;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA,oBAAoB;AACpB,kBAAkB;AAClB,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA,mBAAmB,sCAAsC,yBAAyB;AAClF;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA,mBAAmB,2CAA2C,yBAAyB;AACvF;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA,mBAAmB,0CAA0C,yBAAyB;AACtF;AACA;AACA;AACA;;;;;;;;ACPA,qBAAqB,mBAAO,CAAC,GAAyB;AACtD,gBAAgB,mBAAO,CAAC,GAAoB;AAC5C,oBAAoB,mBAAO,CAAC,GAAwB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,iBAAiB,sBAAsB;AACvC,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,iBAAiB,sBAAsB;AACvC,OAAO;AACP,KAAK;AACL;AACA,MAAM,uFAAuF,QAAQ,gBAAgB;AACrH;AACA,MAAM,uEAAuE,QAAQ,gBAAgB;AACrG,MAAM,uEAAuE,QAAQ,gBAAgB;AACrG,MAAM,sEAAsE,QAAQ,gBAAgB;AACpG,MAAM,wEAAwE,QAAQ,gBAAgB;AACtG,MAAM,uEAAuE,QAAQ,gBAAgB;AACrG;AACA;AACA;;;;;;;;AC/BA;AACA;AACA,sBAAsB,4BAA4B;AAClD,gDAAgD,4BAA4B;AAC5E;;AAEA,wBAAwB,kBAAkB;AAC1C,kDAAkD,kBAAkB;AACpE;AACA;;AAEA;AACA;;;;;;;;ACZA;AACA;AACA,mBAAmB,6BAA6B;AAChD,qDAAqD,6BAA6B;AAClF;;AAEA,mBAAmB,6BAA6B;AAChD,qDAAqD,6BAA6B;AAClF;;AAEA,kBAAkB,6BAA6B;AAC/C,oDAAoD,6BAA6B;AACjF;;AAEA,oBAAoB,qCAAqC;AACzD,sDAAsD,qCAAqC;AAC3F;;AAEA,mBAAmB,kBAAkB;AACrC,qDAAqD,kBAAkB;AACvE;AACA;;AAEA;AACA;;;;;;;;ACxBA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;;AAEA;AACA;;;;;;;;ACRA,WAAW,mBAAO,CAAC,GAAiB;AACpC,qBAAqB,mBAAO,CAAC,EAA2B;AACxD,gBAAgB,mBAAO,CAAC,GAAsB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACXA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://egg-born-module-a-socketio/./backend/src/bean/bean.io.js","webpack://egg-born-module-a-socketio/./backend/src/bean/broadcast.socketEmit.js","webpack://egg-born-module-a-socketio/./backend/src/bean/local.ioMessageBase.js","webpack://egg-born-module-a-socketio/./backend/src/bean/local.message.js","webpack://egg-born-module-a-socketio/./backend/src/bean/local.messageClass.js","webpack://egg-born-module-a-socketio/./backend/src/bean/local.procedure.js","webpack://egg-born-module-a-socketio/./backend/src/bean/middleware.connection.js","webpack://egg-born-module-a-socketio/./backend/src/bean/middleware.packet.js","webpack://egg-born-module-a-socketio/./backend/src/bean/queue.delivery.js","webpack://egg-born-module-a-socketio/./backend/src/bean/queue.process.js","webpack://egg-born-module-a-socketio/./backend/src/bean/queue.push.js","webpack://egg-born-module-a-socketio/./backend/src/bean/queue.pushDirect.js","webpack://egg-born-module-a-socketio/./backend/src/bean/version.manager.js","webpack://egg-born-module-a-socketio/./backend/src/beans.js","webpack://egg-born-module-a-socketio/./backend/src/common/ioChannelBase.js","webpack://egg-born-module-a-socketio/./backend/src/config/config.js","webpack://egg-born-module-a-socketio/./backend/src/config/errors.js","webpack://egg-born-module-a-socketio/./backend/src/config/locale/zh-cn.js","webpack://egg-born-module-a-socketio/./backend/src/config/locales.js","webpack://egg-born-module-a-socketio/./backend/src/config/socketio/messageSystem.js","webpack://egg-born-module-a-socketio/./backend/src/config/validation/schemas.js","webpack://egg-born-module-a-socketio/./backend/src/controller/io.js","webpack://egg-born-module-a-socketio/./backend/src/controller/message.js","webpack://egg-born-module-a-socketio/./backend/src/controller/messageClass.js","webpack://egg-born-module-a-socketio/./backend/src/controllers.js","webpack://egg-born-module-a-socketio/./backend/src/main.js","webpack://egg-born-module-a-socketio/./backend/src/meta.js","webpack://egg-born-module-a-socketio/./backend/src/model/message.js","webpack://egg-born-module-a-socketio/./backend/src/model/messageClass.js","webpack://egg-born-module-a-socketio/./backend/src/model/messageSync.js","webpack://egg-born-module-a-socketio/./backend/src/models.js","webpack://egg-born-module-a-socketio/./backend/src/routes.js","webpack://egg-born-module-a-socketio/./backend/src/service/io.js","webpack://egg-born-module-a-socketio/./backend/src/service/message.js","webpack://egg-born-module-a-socketio/./backend/src/service/messageClass.js","webpack://egg-born-module-a-socketio/./backend/src/services.js","webpack://egg-born-module-a-socketio/external commonjs2 \"require3\"","webpack://egg-born-module-a-socketio/webpack/bootstrap","webpack://egg-born-module-a-socketio/webpack/before-startup","webpack://egg-born-module-a-socketio/webpack/startup","webpack://egg-born-module-a-socketio/webpack/after-startup"],"sourcesContent":["const require3 = require('require3');\nconst debug = require3('debug')('io');\nconst uuid = require3('uuid');\n\nconst SOCKETSONLINE = Symbol.for('APP#__SOCKETSONLINE');\n\nmodule.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class IO {\n    constructor() {\n      this._redis = null;\n    }\n\n    get messageClass() {\n      return ctx.bean._getBean(moduleInfo.relativeName, 'local.messageClass');\n    }\n\n    get message() {\n      return ctx.bean._getBean(moduleInfo.relativeName, 'local.message');\n    }\n\n    get redis() {\n      if (!this._redis) this._redis = ctx.app.redis.get('io') || ctx.app.redis.get('cache');\n      return this._redis;\n    }\n\n    _getSocketsOnline() {\n      if (!ctx.app[SOCKETSONLINE]) {\n        ctx.app[SOCKETSONLINE] = {};\n      }\n      return ctx.app[SOCKETSONLINE];\n    }\n\n    _registerSocket(socketId, socket) {\n      debug('_registerSocket: workerId:%s, socketId:%s', ctx.app.meta.workerId, socketId);\n      const socketsOnline = this._getSocketsOnline();\n      socketsOnline[socketId] = socket;\n    }\n\n    _unRegisterSocket(socketId) {\n      debug('_unRegisterSocket: workerId:%s, socketId:%s', ctx.app.meta.workerId, socketId);\n      const socketsOnline = this._getSocketsOnline();\n      delete socketsOnline[socketId];\n    }\n\n    // subcribe\n    //    hash key: userId:path\n    //    hash value: scene -> workerId:socketId\n    async subscribe({ subscribes, socketId, user }) {\n      for (const item of subscribes) {\n        const path = item.path;\n        if (!path) ctx.throw(403);\n        const scene = item.scene || '';\n        const key = `sub:${ctx.instance.id}:${user.id}:${path}`;\n        const value = socketId;\n        debug('subscribe: key:%s, scene:%s, value:%s', key, scene, value);\n        await this.redis.hset(key, scene, value);\n      }\n    }\n\n    async unsubscribe({ subscribes, user }) {\n      for (const item of subscribes) {\n        const path = item.path;\n        if (!path) ctx.throw(403);\n        const scene = item.scene || '';\n        const socketId = item.socketId;\n        if (!socketId) continue;\n        const key = `sub:${ctx.instance.id}:${user.id}:${path}`;\n        // check if socketId is consistent\n        const value = await this.redis.hget(key, scene);\n        if (value === socketId) {\n          await this.redis.hdel(key, scene);\n        }\n      }\n    }\n\n    async unsubscribeWhenDisconnect({ iid, user, socketId }) {\n      const keyPrefix = this.redis.options.keyPrefix;\n      const keyPatern = `${keyPrefix}${iid}:${user.id}:*`;\n      const keys = await this.redis.keys(keyPatern);\n      for (const fullKey of keys) {\n        const key = fullKey.substr(keyPrefix.length);\n        const values = await this.redis.hgetall(key);\n        if (!values) continue;\n        for (const scene in values) {\n          const value = values[scene];\n          if (value === socketId) {\n            await this.redis.hdel(key, scene);\n          }\n        }\n      }\n    }\n\n    async pushDirect({ content, channel, options }) {\n      ctx.meta.util.queuePush({\n        module: moduleInfo.relativeName,\n        queueName: 'pushDirect',\n        data: {\n          content,\n          channel,\n          options,\n        },\n      });\n    }\n\n    async publish({ path, message, messageClass, options }) {\n      // messageClass\n      messageClass = await this.messageClass.get(messageClass);\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      const beanMessage = this._getBeanMessage(messageClassBase);\n      return await beanMessage.onPublish({ path, message, messageClass, options });\n    }\n\n    // called by messageBase.onPublish\n    async _publish({ path, message, messageClass, options }) {\n      // messageClass\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      const beanMessage = this._getBeanMessage(messageClassBase);\n      // options\n      options = options || {};\n      // scene\n      if (options.scene === undefined) {\n        options.scene = ctx.headers['x-clientid'] || '';\n      }\n      const messageScene = options.scene;\n\n      // message/userId\n      message.userIdFrom = parseInt(message.userIdFrom || 0);\n      if (message.userIdTo === undefined || message.userIdTo === null) message.userIdTo = -3;\n      message.userIdTo = parseInt(message.userIdTo || 0);\n      const userIdFrom = message.userIdFrom;\n      const userIdTo = message.userIdTo;\n      // userIdsTo\n      if (message.userIdsTo) {\n        message.userIdsTo = message.userIdsTo.map(userId => parseInt(userId));\n      }\n      // sessionId\n      const sessionId = await beanMessage.onSessionId({ path, message, options });\n      // message\n      const _message = {\n        messageClassId: messageClass.id,\n        messageType: message.messageType,\n        messageFilter: message.messageFilter,\n        messageGroup: message.messageGroup,\n        messageScene,\n        userIdTo,\n        userIdFrom,\n        sessionId,\n        content: JSON.stringify(message.content), // should use string for db/queue\n      };\n\n      // save\n      if (this._checkPersistence({ options, message, messageClass })) {\n        _message.id = await this.message.save({ message: _message });\n        _message.createdAt = new Date();\n      } else {\n        _message.id = message.id || uuid.v4();\n        _message.createdAt = new Date();\n      }\n\n      // userIdsTo: not save, but use as save syncs\n      if (message.userIdsTo) {\n        _message.userIdsTo = message.userIdsTo;\n      }\n\n      // messageClass\n      _message.module = messageClass.module;\n      _message.messageClassName = messageClass.messageClassName;\n\n      // debug\n      debug(\n        '_publish message: id:%s, scene:%s, userIdFrom:%d, userIdTo:%d, userIdsTo:%j',\n        _message.id,\n        _message.messageScene,\n        _message.userIdFrom,\n        _message.userIdTo,\n        _message.userIdsTo\n      );\n      debug('_publish path: %s', path);\n      debug('_publish content: %j', message.content);\n\n      // to queue\n      ctx.meta.util.queuePush({\n        module: moduleInfo.relativeName,\n        queueName: 'process',\n        data: {\n          path,\n          options,\n          message: _message,\n          messageClass,\n        },\n      });\n\n      // ok\n      return {\n        id: _message.id,\n      };\n    }\n\n    // queue: process\n    async queueProcess({ path, options, message, messageClass }) {\n      // messageClass\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      const beanMessage = this._getBeanMessage(messageClassBase);\n      // messageSyncs\n      const messageSyncs = await beanMessage.onSaveSyncs({ path, options, message, messageClass });\n      // onProcess\n      await beanMessage.onProcess({ path, options, message, messageSyncs, messageClass });\n    }\n\n    _checkPersistence({ options, message, messageClass }) {\n      // 1.\n      if (message.userIdTo === -2 || message.userIdsTo) return true;\n      // 2.\n      if (options && options.persistence !== undefined) return options.persistence;\n      // 3.\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      return messageClassBase.info.persistence;\n    }\n\n    // support userIdTo/userIdsTo\n    //   userIdTo: 0/-1/-2/-3\n    async _onSaveSyncs({ path, options, message, messageClass }) {\n      // messageClass\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      const beanMessage = this._getBeanMessage(messageClassBase);\n      // persistence\n      const persistence = this._checkPersistence({ options, message, messageClass });\n      // messageClassId\n      const messageClassId = messageClass.id;\n      // messageId\n      const messageId = message.id;\n      // message syncs\n      let messageSyncs = [];\n      // saveLimit\n      const saveLimit = ctx.config.module(moduleInfo.relativeName).message.sync.saveLimit;\n      // sender\n      //   not save ===0\n      if (message.userIdFrom !== 0) {\n        // save\n        const messageSync = {\n          messageClassId,\n          messageId,\n          userId: message.userIdFrom,\n          messageDirection: 1,\n          messageRead: 1,\n        };\n        if (persistence) {\n          messageSync.id = await this.message.saveSync({ messageSync });\n        } else {\n          messageSync.id = uuid.v4();\n        }\n        // extensible\n        await beanMessage.onSaveSync({ path, options, message, messageSync, messageClass });\n        // push\n        messageSyncs.push(messageSync);\n      }\n      // receiver\n      await beanMessage.onSaveSyncsPolicy({\n        path,\n        options,\n        message,\n        messageClass,\n        saveLimit,\n        onSave: async userIds => {\n          // over limit\n          if (messageSyncs && messageSyncs.length > 1) {\n            // means enter this callback again\n            messageSyncs = null;\n          }\n          // syncs\n          for (const userIdTo of userIds) {\n            if (userIdTo !== message.userIdFrom && userIdTo !== 0) {\n              // save\n              const messageSync = {\n                messageClassId,\n                messageId,\n                userId: userIdTo,\n                messageDirection: 2, // receive\n                messageRead: 0,\n              };\n              if (persistence) {\n                messageSync.id = await this.message.saveSync({ messageSync });\n              } else {\n                messageSync.id = uuid.v4();\n              }\n              // extensible\n              await beanMessage.onSaveSync({ path, options, message, messageSync, messageClass });\n              // push\n              if (messageSyncs) {\n                messageSyncs.push(messageSync);\n              }\n            }\n          }\n        },\n      });\n      // array / null\n      return messageSyncs;\n    }\n\n    // support userIdTo/userIdsTo\n    //   userIdTo: 0/-1/-2/-3\n    async _onSaveSyncsPolicy({ path, options, message, messageClass, saveLimit, onSave }) {\n      // userIdsTo\n      if (message.userIdsTo) {\n        return await this._onSaveSyncsPolicy_userIdsTo({ path, options, message, messageClass, saveLimit, onSave });\n      }\n      // -1\n      if (message.userIdTo === -1) {\n        // only delivery to the online users\n        return await onSave([message.userIdTo]);\n      } else if (message.userIdTo === -2) {\n        // all users\n        return await this._onSaveSyncsPolicy_userIdsAll({ path, options, message, messageClass, saveLimit, onSave });\n      } else if (message.userIdTo === -3) {\n        // unkonwn user, but also should create messageSync for push\n        return await onSave([message.userIdTo]);\n      } else if (message.userIdTo === 0) {\n        // system user: ignore\n        return await onSave([]);\n      }\n      // normal user\n      return await onSave([message.userIdTo]);\n    }\n\n    async _onSaveSyncsPolicy_userIdsTo({ message, saveLimit, onSave }) {\n      const loop = Math.ceil(message.userIdsTo.length / saveLimit);\n      for (let i = 0; i < loop; i++) {\n        const userIds = message.userIdsTo.slice(i * saveLimit, (i + 1) * saveLimit);\n        await onSave(userIds);\n      }\n    }\n\n    async _onSaveSyncsPolicy_userIdsAll({ saveLimit, onSave }) {\n      const modelUser = ctx.model.module('a-base').user;\n      let offset = 0;\n      // eslint-disable-next-line\n      while (true) {\n        // users\n        const users = await modelUser.select({\n          where: { disabled: 0 },\n          columns: ['id'],\n          limit: saveLimit,\n          offset,\n        });\n        // save\n        await onSave(users.map(item => item.id));\n        // next\n        if (users.length < saveLimit) {\n          break;\n        } else {\n          offset += saveLimit;\n        }\n      }\n    }\n\n    // called by messageBase.onProcess\n    async _onProcessBase({ path, options, message, messageSyncs, messageClass }) {\n      // to queue: delivery/push\n      if (path) {\n        // try delivery first, then try push if failed\n        ctx.meta.util.queuePush({\n          module: moduleInfo.relativeName,\n          queueName: 'delivery',\n          data: {\n            path,\n            options,\n            message,\n            messageSyncs,\n            messageClass,\n          },\n        });\n      } else {\n        // push\n        await this._pushQueuePush({ options, message, messageSyncs, messageClass });\n      }\n    }\n\n    // queue: delivery\n    async queueDelivery({ path, options, message, messageSyncs, messageClass }) {\n      // bean\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      const beanMessage = this._getBeanMessage(messageClassBase);\n      // loop\n      await this._loopMessageSyncs({\n        options,\n        message,\n        messageSyncs,\n        messageClass,\n        onHandle: async messageSync => {\n          if (messageSync.userId === -1) {\n            // must be set path\n            if (path) {\n              // broadcast to online users\n              const userIds = await this._getPathUsersOnline({ path });\n              for (const userId of userIds) {\n                const _messageSync = {\n                  ...messageSync,\n                  userId,\n                };\n                await beanMessage.onDelivery({ path, options, message, messageSync: _messageSync, messageClass });\n              }\n            }\n          } else {\n            // normal\n            await beanMessage.onDelivery({ path, options, message, messageSync, messageClass });\n          }\n        },\n      });\n    }\n\n    async _loopMessageSyncs({ message, messageSyncs, onHandle }) {\n      // array\n      if (messageSyncs) {\n        for (const messageSync of messageSyncs) {\n          await onHandle(messageSync);\n        }\n        return;\n      }\n      // from db\n      // saveLimit\n      const saveLimit = ctx.config.module(moduleInfo.relativeName).message.sync.saveLimit;\n      const modelMessageSync = this.message.modelMessageSync;\n      let offset = 0;\n      // eslint-disable-next-line\n      while (true) {\n        // mess\n        const messageSyncs = await modelMessageSync.select({\n          where: {\n            messageId: message.id,\n            // messageRead:0, ??\n          },\n          limit: saveLimit,\n          offset,\n        });\n        // handle\n        for (const messageSync of messageSyncs) {\n          await onHandle(messageSync);\n        }\n        // next\n        if (messageSyncs.length < saveLimit) {\n          break;\n        } else {\n          offset += saveLimit;\n        }\n      }\n    }\n\n    async _pushQueuePush({ options, message, messageSyncs, messageClass }) {\n      // check if enable push\n      const pushEnable = await this._checkPushEnable({ options, message, messageSyncs, messageClass });\n      if (!pushEnable) return;\n      // queue\n      ctx.meta.util.queuePush({\n        module: moduleInfo.relativeName,\n        queueName: 'push',\n        data: {\n          options,\n          message,\n          messageSyncs,\n          messageClass,\n        },\n      });\n    }\n\n    // queue: push\n    async queuePush({ options, message, messageSyncs, messageClass }) {\n      // bean\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      const beanMessage = this._getBeanMessage(messageClassBase);\n      // loop\n      await this._loopMessageSyncs({\n        options,\n        message,\n        messageSyncs,\n        messageClass,\n        onHandle: async messageSync => {\n          await beanMessage.onPush({ options, message, messageSync, messageClass });\n        },\n      });\n    }\n\n    async push({ options, message, messageSync, messageClass }) {\n      // userId\n      const userId = messageSync.userId;\n      const isSender = message.userIdFrom === userId;\n      // ignore sender\n      if (isSender) return true;\n      // adjust auto\n      const autoFirstValid = !options || !options.push || options.push.AtMostOnce !== false;\n      // channels\n      const channels = await this._getChannels({ options, message, messageSync, messageClass });\n      if (!channels) return false;\n      // loop\n      let atLeastDone = false;\n      for (const channelFullName of channels) {\n        const res = await this._pushChannel({ options, message, messageSync, messageClass, channelFullName });\n        if (!res) continue;\n        atLeastDone = true;\n        if (autoFirstValid) break;\n      }\n      // log\n      if (!atLeastDone) {\n        ctx.logger.info('not found any valid channel for this message:', message);\n        return false;\n      }\n      // done\n      return true;\n    }\n\n    async _checkPushEnable({ options, message, messageSyncs, messageClass }) {\n      // options maybe set push.channels\n      const channels = options && options.push && options.push.channels;\n      if (channels) return true;\n      // bean\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      const beanMessage = this._getBeanMessage(messageClassBase);\n      // check if enable push\n      return await beanMessage.onPushEnable({ options, message, messageSyncs, messageClass });\n    }\n\n    async _getChannels({ options, message, messageSync, messageClass }) {\n      // options maybe set push.channels\n      const channels = options && options.push && options.push.channels;\n      if (channels) return channels;\n      // bean\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      const beanMessage = this._getBeanMessage(messageClassBase);\n      return await beanMessage.onChannels({ options, message, messageSync, messageClass });\n    }\n\n    async _pushChannel({ options, message, messageSync, messageClass, channelFullName }) {\n      try {\n        // bean\n        const messageClassBase = this.messageClass.messageClass(messageClass);\n        const beanMessage = this._getBeanMessage(messageClassBase);\n        if (!beanMessage) return false;\n        // render message content\n        const content = await beanMessage.onChannelRender({\n          channelFullName,\n          options,\n          message,\n          messageSync,\n          messageClass,\n        });\n        if (!content) return false;\n        // get channel base\n        const beanChannel = this._getBeanChannel(channelFullName);\n        if (!beanChannel) {\n          return false;\n        }\n        // push\n        const pushDone = await beanChannel.onPush({ content, options, message, messageSync, messageClass });\n        if (!pushDone) return false;\n        // done this channel\n        return true;\n      } catch (err) {\n        // log\n        ctx.logger.error(err);\n        return false;\n      }\n    }\n\n    async queuePushDirect({ content, options, channel }) {\n      // get channel base\n      const channelFullName = `${channel.module}:${channel.name}`;\n      const beanChannel = this._getBeanChannel(channelFullName);\n      if (!beanChannel) {\n        return false;\n      }\n      const pushDone = await beanChannel.onPush({ content, options });\n      // done\n      return pushDone;\n    }\n\n    _getBeanChannel(channelFullName) {\n      // get channel base\n      const channelBase = this.messageClass.channel(channelFullName);\n      if (!channelBase) {\n        ctx.logger.info(`channel not found: ${channelFullName}`);\n        return null;\n      }\n      // bean\n      const beanFullName = `${channelBase.info.module}.io.channel.${channelBase.info.bean}`;\n      const beanChannel = ctx.bean._getBean(beanFullName);\n      if (!beanChannel) {\n        ctx.logger.info(`channel bean not found: ${beanFullName}`);\n        return null;\n      }\n      return beanChannel;\n    }\n\n    _getBeanMessage(messageClassBase) {\n      // beanFullName\n      let beanFullName;\n      if (messageClassBase.info.bean) {\n        beanFullName = `${messageClassBase.info.module}.io.message.${messageClassBase.info.bean}`;\n      } else if (messageClassBase.info.uniform) {\n        beanFullName = 'a-message.local.ioMessageUniformBase';\n      } else {\n        beanFullName = 'a-socketio.local.ioMessageBase';\n      }\n      // bean\n      const beanMessage = ctx.bean._getBean(beanFullName);\n      if (!beanMessage) {\n        ctx.logger.info(`message bean not found: ${beanFullName}`);\n        return null;\n      }\n      return beanMessage;\n    }\n\n    async _getPathUsersOnline({ path }) {\n      const keyUserIndex = 2;\n      const userIds = [];\n      const keyPrefix = this.redis.options.keyPrefix;\n      const keyPatern = `${keyPrefix}sub:${ctx.instance.id}:*:${path}`;\n      const keys = await this.redis.keys(keyPatern);\n      for (const fullKey of keys) {\n        const key = fullKey.substr(keyPrefix.length);\n        userIds.push(parseInt(key.split(':')[keyUserIndex]));\n      }\n      return userIds;\n    }\n\n    // called by messageBase.onDelivery\n    async delivery({ path, options, message, messageSync, messageClass }) {\n      // ignore delivery online if !path\n      if (path) {\n        const deliveryDone = await this.emit({ path, options, message, messageSync, messageClass });\n        if (deliveryDone) return;\n      }\n      // to queue: push\n      await this._pushQueuePush({ options, message, messageSyncs: [messageSync], messageClass });\n    }\n\n    // offline: return false\n    //    hash key: userId:path\n    //    hash value: scene -> workerId:socketId\n    async emit({ path, options, message, messageSync /* , messageClass*/ }) {\n      // userId\n      const userId = messageSync.userId;\n      if (!userId) return true;\n      // options\n      const messageScene = (options && options.scene) || '';\n      // // no scene\n      // if (!messageScene) {\n      //   return await this._emitNoScene({ path, message, messageSync, messageScene });\n      // }\n      // scene\n      return await this._emitScene({ path, message, messageSync, messageScene });\n    }\n\n    // async _emitNoScene({ path, message, messageSync, messageScene }) {\n    //   // userId\n    //   const userId = messageSync.userId;\n    //   const isSender = message.userIdFrom === userId;\n    //   // ignore sender\n    //   if (isSender) return true;\n    //   // get hash value\n    //   const key = `sub:${ctx.instance.id}:${userId}:${path}`;\n    //   const socketId = await this.redis.hget(key, messageScene);\n    //   if (!socketId) return false; // offline\n    //   // emit\n    //   this._emitSocket({ path, message, socketId });\n    //   // done\n    //   return true;\n    // }\n\n    // return true when any emitSocket\n    async _emitScene({ path, message, messageSync, messageScene }) {\n      // userId\n      const userId = messageSync.userId;\n      const isSender = message.userIdFrom === userId;\n      // debug\n      debug(\n        '_emitScene message: id:%s, scene:%s, userIdFrom:%d, userIdTo:%d, path:%s',\n        message.id,\n        messageScene,\n        message.userIdFrom,\n        userId,\n        path\n      );\n      // get hash value\n      const key = `sub:${ctx.instance.id}:${userId}:${path}`;\n      const values = await this.redis.hgetall(key);\n      if (!values) {\n        // offline\n        //  only support offline-notification for receiver\n        return !!isSender;\n      }\n      let bSent = false;\n      for (const scene in values) {\n        if (!isSender || scene !== messageScene) {\n          const socketId = values[scene];\n          debug('_emitScene message socket: socketId:%s', socketId);\n          this._emitSocket({ path, message, socketId });\n          bSent = true;\n        }\n      }\n      if (!bSent) {\n        // offline\n        //  only support offline-notification for receiver\n        return !!isSender;\n      }\n      // done\n      return true;\n    }\n\n    _emitSocket({ path, message, socketId }) {\n      // broadcast\n      ctx.meta.util.broadcastEmit({\n        module: moduleInfo.relativeName,\n        broadcastName: 'socketEmit',\n        data: { path, message, socketId },\n      });\n    }\n\n    async publishMessageSystem({ message }) {\n      await this.publish({\n        path: '/a/socketio/messageSystem',\n        message,\n        messageClass: {\n          module: moduleInfo.relativeName,\n          messageClassName: 'messageSystem',\n        },\n      });\n    }\n  }\n  return IO;\n};\n","const require3 = require('require3');\nconst debug = require3('debug')('io');\n\nconst SOCKETSONLINE = Symbol.for('APP#__SOCKETSONLINE');\nmodule.exports = app => {\n  class Broadcast extends app.meta.BeanBase {\n    async execute(context) {\n      const data = context.data;\n      const socketsOnline = app[SOCKETSONLINE];\n      const socket = socketsOnline && socketsOnline[data.socketId];\n      debug('socketEmit broadcast: found:%d, workerId:%s, socketId:%s', !!socket, app.meta.workerId, data.socketId);\n      if (socket) {\n        socket.emit('message', {\n          path: data.path,\n          message: data.message,\n        });\n      }\n    }\n  }\n\n  return Broadcast;\n};\n","module.exports = ctx => {\n  class IOMessageBase {\n    async onSessionId({ /* path,*/ message /* options*/ }) {\n      const userIdFrom = message.userIdFrom;\n      const userIdTo = message.userIdTo;\n      return message.messageGroup ? userIdTo : this._combineSessionId(userIdFrom, userIdTo);\n    }\n\n    async onProcess({ path, options, message, messageSyncs, messageClass }) {\n      return await ctx.bean.io._onProcessBase({ path, options, message, messageSyncs, messageClass });\n    }\n\n    async onSaveSyncs({ path, options, message, messageClass }) {\n      return await ctx.bean.io._onSaveSyncs({ path, options, message, messageClass });\n    }\n\n    async onSaveSyncsPolicy({ path, options, message, messageClass, saveLimit, onSave }) {\n      return await ctx.bean.io._onSaveSyncsPolicy({ path, options, message, messageClass, saveLimit, onSave });\n    }\n\n    async onSaveSync(/* { path, options, message, messageSync, messageClass }*/) {\n      return null;\n    }\n\n    async onDelivery({ path, options, message, messageSync, messageClass }) {\n      return await ctx.bean.io.delivery({ path, options, message, messageSync, messageClass });\n    }\n\n    async onPushEnable({ /* options, message, messageSyncs,*/ messageClass }) {\n      const messageClassBase = ctx.bean.io.messageClass.messageClass(messageClass);\n      return !!(messageClassBase.info.push && messageClassBase.info.push.channels);\n    }\n\n    async onPush({ options, message, messageSync, messageClass }) {\n      return await ctx.bean.io.push({ options, message, messageSync, messageClass });\n    }\n\n    async onChannels({ /* options, message, messageSync,*/ messageClass }) {\n      const messageClassBase = ctx.bean.io.messageClass.messageClass(messageClass);\n      return messageClassBase.info.push && messageClassBase.info.push.channels;\n    }\n\n    async onChannelRender(/* { channelFullName, options, message, messageSync, messageClass }*/) {\n      return null;\n    }\n\n    async onPublish({ path, message, messageClass, options }) {\n      return await ctx.bean.io._publish({ path, message, messageClass, options });\n    }\n\n    async onSetRead({ messageClass, messageIds, all, user }) {\n      return await ctx.bean.io.message._setRead({ messageClass, messageIds, all, user });\n    }\n\n    // combine sessionId\n    _combineSessionId(userIdFrom, userIdTo) {\n      if (userIdFrom === userIdTo) return userIdFrom;\n      return `${userIdFrom > userIdTo ? userIdFrom : userIdTo}:${userIdFrom < userIdTo ? userIdFrom : userIdTo}`;\n    }\n  }\n  return IOMessageBase;\n};\n","// const require3 = require('require3');\n// const uuid = require3('uuid');\n\nmodule.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class MessageClass {\n    constructor() {\n      this._sqlProcedure = null;\n    }\n\n    get modelMessage() {\n      return ctx.model.module(moduleInfo.relativeName).message;\n    }\n\n    get modelMessageSync() {\n      return ctx.model.module(moduleInfo.relativeName).messageSync;\n    }\n\n    get sqlProcedure() {\n      return ctx.bean._getBean(moduleInfo.relativeName, 'local.procedure');\n    }\n\n    async save({ message }) {\n      // insert\n      const res = await this.modelMessage.insert(message);\n      return res.insertId;\n    }\n\n    async saveSync({ messageSync }) {\n      // insert\n      const res = await this.modelMessageSync.insert(messageSync);\n      return res.insertId;\n    }\n\n    // the first unread message\n    // options:\n    //    where\n    async offset({ messageClass, options, user }) {\n      // messageClass\n      messageClass = await ctx.bean.io.messageClass.get(messageClass);\n      // where\n      const where = (options && options.where) || {};\n      where.iid = ctx.instance.id;\n      where.deleted = 0;\n      where.syncDeleted = 0;\n      where.messageClassId = messageClass.id;\n      where.userId = user ? user.id : 0;\n      // messageRead\n      if (where.messageRead === null) {\n        delete where.messageRead;\n      } else if (where.messageRead === undefined) {\n        where.messageRead = 0;\n      }\n      // orders\n      const _orders = (options && options.orders) || [['id', 'asc']];\n      // offset\n      const _offset = (options && options.offset) || 0;\n      // offset\n      const res = await ctx.db.select('aSocketIOMessageView', {\n        where,\n        columns: ['id'],\n        orders: _orders,\n        limit: 1,\n        offset: _offset,\n      });\n      // offset - 1\n      const offset = res[0] ? res[0].id - 1 : -1;\n      return { offset };\n    }\n\n    async select({ messageClass, options, user }) {\n      return await this._list({ messageClass, options, user, count: 0 });\n    }\n\n    async count({ messageClass, options, user }) {\n      const count = await this._list({ messageClass, options, user, count: 1 });\n      return { count };\n    }\n\n    async setRead({ messageClass, messageIds, all, user }) {\n      if ((!messageIds || messageIds.length === 0) && !all) return;\n      if (all && !messageClass) return;\n      // messageClass\n      if (messageClass) {\n        messageClass = await ctx.bean.io.messageClass.get(messageClass);\n        const messageClassBase = ctx.bean.io.messageClass.messageClass(messageClass);\n        const beanMessage = ctx.bean.io._getBeanMessage(messageClassBase);\n        return await beanMessage.onSetRead({ messageClass, messageIds, all, user });\n      }\n      // default\n      return await this._setRead({ messageClass, messageIds, all, user });\n    }\n\n    async _setRead({ messageClass, messageIds, all, user }) {\n      const messageClassId = messageClass ? messageClass.id : 0;\n      // query\n      const sql = this.sqlProcedure.setRead({\n        iid: ctx.instance.id,\n        messageClassId,\n        messageIds,\n        all,\n        userId: user ? user.id : 0,\n      });\n      if (sql) {\n        await ctx.model.query(sql);\n      }\n    }\n\n    async delete({ messageIds, user }) {\n      if (!messageIds || messageIds.length === 0) return;\n      // query\n      const sql = this.sqlProcedure.delete({\n        iid: ctx.instance.id,\n        messageIds,\n        userId: user ? user.id : 0,\n      });\n      await ctx.model.query(sql);\n    }\n\n    async _list({ messageClass, options, user, count }) {\n      // messageClass\n      messageClass = messageClass ? await ctx.bean.io.messageClass.get(messageClass) : null;\n      // where\n      const where = (options && options.where) || {};\n      if (messageClass) {\n        where.messageClassId = messageClass.id;\n      }\n      where.userId = user ? user.id : 0;\n      // orders\n      const orders = (options && options.orders) || [['createdAt', 'asc']];\n      // query\n      const sql = this.sqlProcedure.selectMessages({\n        iid: ctx.instance.id,\n        where,\n        orders,\n        page: options.page,\n        offset: options.offset,\n        count,\n      });\n      const res = await ctx.model.query(sql);\n      return count ? res[0]._count : res;\n    }\n  }\n  return MessageClass;\n};\n\n// async saveSyncs({ messageClass, message, groupUsers, persistence }) {\n//   // messageClassId\n//   const messageClassId = messageClass.id;\n//   // messageId\n//   const messageId = message.id;\n//   // message sync\n//   const messageSyncs = [];\n//   //  :userIdFrom\n//   const isSame = message.userIdTo === message.userIdFrom;\n//   messageSyncs.push({\n//     messageClassId,\n//     messageId,\n//     userId: message.userIdFrom,\n//     messageDirection: 1, // only use send\n//     messageRead: 1,\n//   });\n//   //  :userIdTo\n//   if (!message.messageGroup) {\n//     // single chat\n//     if (!isSame) {\n//       messageSyncs.push({\n//         messageClassId,\n//         messageId,\n//         userId: message.userIdTo,\n//         messageDirection: 2, // receive\n//         messageRead: 0,\n//       });\n//     }\n//   } else {\n//     // group chat\n//     if (groupUsers) {\n//       for (const groupUser of groupUsers) {\n//         const _userIdTo = groupUser.userId;\n//         if (_userIdTo !== message.userIdFrom) {\n//           messageSyncs.push({\n//             messageClassId,\n//             messageId,\n//             userId: _userIdTo,\n//             messageDirection: 2, // receive\n//             messageRead: 0,\n//           });\n//         }\n//       }\n//     }\n//   }\n//   //  :save\n//   for (const messageSync of messageSyncs) {\n//     // userId===0 not save to db\n//     if (persistence && messageSync.userId !== 0) {\n//       const res = await this.modelMessageSync.insert(messageSync);\n//       messageSync.messageSyncId = res.insertId;\n//     } else {\n//       messageSync.messageSyncId = uuid.v4();\n//     }\n//   }\n//   // ok\n//   return messageSyncs;\n// }\n","const require3 = require('require3');\nconst extend = require3('@zhennann/extend');\n\nconst _cacheMessageClasses = {};\nconst _cacheChannels = {};\n\nmodule.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class MessageClass {\n    get modelMessageClass() {\n      return ctx.model.module(moduleInfo.relativeName).messageClass;\n    }\n\n    async getMessageClassId({ id, module, messageClassName }) {\n      if (id) return id;\n      const messageClass = await this.get({ module, messageClassName });\n      return messageClass.id;\n    }\n\n    async get({ id, module, messageClassName }) {\n      const data = id ? { id } : { module, messageClassName };\n      const res = await this.modelMessageClass.get(data);\n      if (res) return res;\n      if (!module || !messageClassName) throw new Error('Invalid arguments');\n      // lock\n      return await ctx.meta.util.lock({\n        resource: `${moduleInfo.relativeName}.messageClass.register`,\n        fn: async () => {\n          return await ctx.meta.util.executeBeanIsolate({\n            beanModule: moduleInfo.relativeName,\n            fn: async ({ ctx }) => {\n              return await ctx.bean.io.messageClass._registerLock({ module, messageClassName });\n            },\n          });\n        },\n      });\n    }\n\n    async _registerLock({ module, messageClassName }) {\n      // get\n      const res = await this.modelMessageClass.get({ module, messageClassName });\n      if (res) return res;\n      // data\n      const messageClass = this.messageClass({ module, messageClassName });\n      if (!messageClass) throw new Error(`messageClass ${module}:${messageClassName} not found!`);\n      const data = {\n        module,\n        messageClassName,\n        uniform: messageClass.info.uniform ? 1 : 0,\n      };\n      // insert\n      const res2 = await this.modelMessageClass.insert(data);\n      data.id = res2.insertId;\n      return data;\n    }\n\n    messageClasses() {\n      if (!_cacheMessageClasses[ctx.locale]) {\n        _cacheMessageClasses[ctx.locale] = this._prepareMessageClasses();\n      }\n      return _cacheMessageClasses[ctx.locale];\n    }\n\n    messageClass({ module, messageClassName }) {\n      const _messageClasses = this.messageClasses();\n      return _messageClasses[module] && _messageClasses[module][messageClassName];\n    }\n\n    _prepareMessageClasses() {\n      const messageClasses = {};\n      for (const relativeName in ctx.app.meta.modules) {\n        const module = ctx.app.meta.modules[relativeName];\n        if (module.main.meta && module.main.meta.socketio && module.main.meta.socketio.messages) {\n          const res = this._prepareMessageClassesModule(module, module.main.meta.socketio.messages);\n          if (Object.keys(res).length > 0) {\n            messageClasses[relativeName] = res;\n          }\n        }\n      }\n      return messageClasses;\n    }\n\n    _prepareMessageClassesModule(module, _messages) {\n      const messageClasses = {};\n      for (const key in _messages) {\n        const message = extend(true, {}, _messages[key]);\n        message.info.module = module.info.relativeName;\n        message.info.name = key;\n        // titleLocale\n        message.info.titleLocale = ctx.text(message.info.title);\n        // ok\n        messageClasses[key] = message;\n      }\n      return messageClasses;\n    }\n\n    channels() {\n      if (!_cacheChannels[ctx.locale]) {\n        _cacheChannels[ctx.locale] = this._prepareChannels();\n      }\n      return _cacheChannels[ctx.locale];\n    }\n\n    // string/object\n    channel(channelFullName) {\n      let module, channelName;\n      if (typeof channelFullName === 'string') {\n        [module, channelName] = channelFullName.split(':');\n      } else {\n        module = channelFullName.module;\n        channelName = channelFullName.channelName;\n      }\n      const _channels = this.channels();\n      return _channels[module] && _channels[module][channelName];\n    }\n\n    _prepareChannels() {\n      const channels = {};\n      for (const relativeName in ctx.app.meta.modules) {\n        const module = ctx.app.meta.modules[relativeName];\n        if (module.main.meta && module.main.meta.socketio && module.main.meta.socketio.channels) {\n          const res = this._prepareChannelsModule(module, module.main.meta.socketio.channels);\n          if (Object.keys(res).length > 0) {\n            channels[relativeName] = res;\n          }\n        }\n      }\n      return channels;\n    }\n\n    _prepareChannelsModule(module, _channels) {\n      const channels = {};\n      for (const key in _channels) {\n        const channel = extend(true, {}, _channels[key]);\n        channel.info.module = module.info.relativeName;\n        channel.info.name = key;\n        // titleLocale\n        channel.info.titleLocale = ctx.text(channel.info.title);\n        // ok\n        channels[key] = channel;\n      }\n      return channels;\n    }\n  }\n  return MessageClass;\n};\n","module.exports = ctx => {\n  class Procedure {\n    selectMessages({ iid, where, orders, page, offset, count }) {\n      // for safe\n      where = where ? ctx.model._where(where) : null;\n      orders = orders ? ctx.model._orders(orders) : null;\n      const limit = page ? ctx.model._limit(page.size, page.index) : null;\n\n      //\n      const _where = where ? `${where} AND` : ' WHERE';\n      const _orders = orders || '';\n      const _limit = limit || '';\n\n      // fields\n      let _selectFields;\n      if (count) {\n        _selectFields = 'count(*) as _count';\n      } else {\n        _selectFields = 'a.*';\n      }\n\n      // offset\n      let _offsetWhere;\n      if (typeof offset === 'number') {\n        _offsetWhere = ` and a.id > ${parseInt(offset)}`;\n      } else {\n        _offsetWhere = '';\n      }\n\n      // sql\n      const _sql = `select ${_selectFields} from aSocketIOMessageView a\n          ${_where}\n           (\n             a.deleted=0 and a.syncDeleted=0 and a.iid=${iid}\n             ${_offsetWhere}\n           )\n          ${count ? '' : _orders}\n          ${count ? '' : _limit}\n        `;\n\n      // ok\n      return _sql;\n    }\n\n    setRead({ iid, messageClassId, messageIds, all, userId }) {\n      if (messageIds && messageIds.length > 0) {\n        const _messageIds = messageIds.map(item => parseInt(item)).join(',');\n\n        // sql\n        const _sql = `update aSocketIOMessageSync set messageRead=1\n          where iid=${iid} and userId=${userId} and messageId in (${_messageIds})\n        `;\n\n        // ok\n        return _sql;\n      } else if (messageClassId > 0 && all) {\n        // sql\n        const _sql = `update aSocketIOMessageSync set messageRead=1\n          where iid=${iid} and userId=${userId} and messageClassId=${messageClassId}\n        `;\n\n        // ok\n        return _sql;\n      }\n      return null;\n    }\n\n    delete({ iid, messageIds, userId }) {\n      const _messageIds = messageIds.map(item => parseInt(item)).join(',');\n\n      // sql\n      const _sql = `update aSocketIOMessageSync set deleted=1\n          where iid=${iid} and userId=${userId} and messageId in (${_messageIds})\n        `;\n\n      // ok\n      return _sql;\n    }\n  }\n\n  return Procedure;\n};\n","const require3 = require('require3');\nconst debug = require3('debug')('io');\n\nmodule.exports = ctx => {\n  const app = ctx.app;\n  class Middleware {\n    async execute(options, next) {\n      // cache userId/socketId for disconnect\n      const user = ctx.state.user && ctx.state.user.op;\n      if (!user || user.anonymous) {\n        // return ctx.throw(401);\n        ctx.socket.emit('message-system', { code: 401, message: 'logout', type: 'self' });\n        return;\n      }\n      // register\n      const iid = user.iid;\n      const socketId = ctx.socket.id;\n      ctx.bean.io._registerSocket(socketId, ctx.socket);\n\n      // register user online\n      await ctx.bean.userOnline.register({ user: ctx.state.user, isLogin: false });\n      // heartbeat\n      const onHeartBeat = this._onHeartBeat.bind(this);\n      ctx.socket.conn.on('heartbeat', onHeartBeat);\n      // next\n      await this._next({ next, user, socketId });\n      ctx.socket.conn.off('heartbeat', onHeartBeat);\n\n      // execute when disconnect\n      ctx.bean.io._unRegisterSocket(socketId);\n      await ctx.bean.io.unsubscribeWhenDisconnect({ iid, user, socketId });\n    }\n\n    async _onHeartBeat() {\n      const user = ctx.state.user;\n      const online = await ctx.bean.userOnline.heartBeat({ user });\n      if (!online) {\n        ctx.socket.emit('message-system', { code: 401, message: 'logout', type: 'self' });\n        // close the underlying connection\n        // ctx.socket.disconnect(true);\n      }\n    }\n\n    async _next({ next, user, socketId }) {\n      debug(`socket io connected: user:${user.id}, socket:${socketId}`);\n      // next\n      await next();\n      debug(`socket io disconnected: user:${user.id}, socket:${socketId}`);\n    }\n  }\n  return Middleware;\n};\n","module.exports = () => {\n  class Middleware {\n    async execute(options, next) {\n      await next();\n    }\n  }\n  return Middleware;\n};\n","module.exports = app => {\n  class Queue extends app.meta.BeanBase {\n    async execute(context) {\n      const { path, options, message, messageSyncs, messageClass } = context.data;\n      return await this.ctx.bean.io.queueDelivery({ path, options, message, messageSyncs, messageClass });\n    }\n  }\n\n  return Queue;\n};\n","module.exports = app => {\n  class Queue extends app.meta.BeanBase {\n    async execute(context) {\n      const { path, options, message, messageClass } = context.data;\n      return await this.ctx.bean.io.queueProcess({ path, options, message, messageClass });\n    }\n  }\n\n  return Queue;\n};\n","module.exports = app => {\n  class Queue extends app.meta.BeanBase {\n    async execute(context) {\n      const { options, message, messageSyncs, messageClass } = context.data;\n      return await this.ctx.bean.io.queuePush({ options, message, messageSyncs, messageClass });\n    }\n  }\n\n  return Queue;\n};\n","module.exports = app => {\n  class Queue extends app.meta.BeanBase {\n    async execute(context) {\n      const { options, content, channel } = context.data;\n      return await this.ctx.bean.io.queuePushDirect({ options, content, channel });\n    }\n  }\n\n  return Queue;\n};\n","module.exports = app => {\n  class Version extends app.meta.BeanBase {\n    async update(options) {\n      if (options.version === 3) {\n        // aSocketIOMessageSync\n        const sql = `\n        ALTER TABLE aSocketIOMessageSync\n          ADD COLUMN messageClassId int(11) DEFAULT '0'\n                  `;\n        await this.ctx.model.query(sql);\n      }\n\n      if (options.version === 2) {\n        // aSocketIOMessageClass\n        const sql = `\n        ALTER TABLE aSocketIOMessageClass\n          ADD COLUMN uniform int(11) DEFAULT '0'\n                  `;\n        await this.ctx.model.query(sql);\n      }\n\n      if (options.version === 1) {\n        let sql;\n\n        // create table: aSocketIOMessageClass\n        sql = `\n          CREATE TABLE aSocketIOMessageClass (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            module varchar(255) DEFAULT NULL,\n            messageClassName varchar(255) DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // create table: aSocketIOMessage\n        sql = `\n          CREATE TABLE aSocketIOMessage (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            messageClassId int(11) DEFAULT '0',\n            messageType int(11) DEFAULT '0',\n            messageFilter varchar(255) DEFAULT NULL,\n            messageGroup int(11) DEFAULT '0',\n            messageScene varchar(50) DEFAULT NULL,\n            userIdTo int(11) DEFAULT '0',\n            userIdFrom int(11) DEFAULT '0',\n            sessionId varchar(255) DEFAULT NULL,\n            content json DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // create table: aSocketIOMessageSync\n        sql = `\n          CREATE TABLE aSocketIOMessageSync (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            messageId int(11) DEFAULT '0',\n            userId int(11) DEFAULT '0',\n            messageDirection int(11) DEFAULT '0',\n            messageRead int(11) DEFAULT '0',\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // create view: aSocketIOMessageView\n        sql = `\n          CREATE VIEW aSocketIOMessageView as\n            select a.*,b.userId,b.messageDirection,b.messageRead,b.deleted as syncDeleted from aSocketIOMessage a\n              left join aSocketIOMessageSync b on a.id=b.messageId\n        `;\n        await this.ctx.model.query(sql);\n      }\n    }\n\n    async init(options) {}\n\n    async test() {}\n  }\n\n  return Version;\n};\n","const versionManager = require('./bean/version.manager.js');\nconst localMessage = require('./bean/local.message.js');\nconst localMessageClass = require('./bean/local.messageClass.js');\nconst localProcedure = require('./bean/local.procedure.js');\nconst localIoMessageBase = require('./bean/local.ioMessageBase.js');\nconst broadcastSocketEmit = require('./bean/broadcast.socketEmit.js');\nconst queueProcess = require('./bean/queue.process.js');\nconst queueDelivery = require('./bean/queue.delivery.js');\nconst queuePush = require('./bean/queue.push.js');\nconst queuePushDirect = require('./bean/queue.pushDirect.js');\nconst middlewareConnection = require('./bean/middleware.connection.js');\nconst middlewarePacket = require('./bean/middleware.packet.js');\nconst beanIO = require('./bean/bean.io.js');\n\nmodule.exports = app => {\n  const beans = {\n    // version\n    'version.manager': {\n      mode: 'app',\n      bean: versionManager,\n    },\n    // local\n    'local.message': {\n      mode: 'ctx',\n      bean: localMessage,\n    },\n    'local.messageClass': {\n      mode: 'ctx',\n      bean: localMessageClass,\n    },\n    'local.procedure': {\n      mode: 'ctx',\n      bean: localProcedure,\n    },\n    'local.ioMessageBase': {\n      mode: 'ctx',\n      bean: localIoMessageBase,\n    },\n    // broadcast\n    'broadcast.socketEmit': {\n      mode: 'app',\n      bean: broadcastSocketEmit,\n    },\n    // queue\n    'queue.process': {\n      mode: 'app',\n      bean: queueProcess,\n    },\n    'queue.delivery': {\n      mode: 'app',\n      bean: queueDelivery,\n    },\n    'queue.push': {\n      mode: 'app',\n      bean: queuePush,\n    },\n    'queue.pushDirect': {\n      mode: 'app',\n      bean: queuePushDirect,\n    },\n    // middleware\n    'middleware.connection': {\n      mode: 'ctx',\n      bean: middlewareConnection,\n    },\n    'middleware.packet': {\n      mode: 'ctx',\n      bean: middlewarePacket,\n    },\n    // global\n    io: {\n      mode: 'ctx',\n      bean: beanIO,\n      global: true,\n    },\n  };\n  return beans;\n};\n","module.exports = (/* ctx*/) => {\n  class IOChannelBase {\n    async onPush(/* { content, options, message, messageSync, messageClass }*/) {\n      return false;\n    }\n  }\n  return IOChannelBase;\n};\n","// eslint-disable-next-line\nmodule.exports = appInfo => {\n  const config = {};\n\n  // middlewares\n  config.middlewares = {\n    connection: {\n      bean: 'connection',\n      type: 'socketio.connection',\n      dependencies: 'connectionAuth',\n    },\n    packet: {\n      bean: 'packet',\n      type: 'socketio.packet',\n    },\n  };\n\n  // queues\n  config.queues = {\n    registerMessageClass: {\n      bean: 'registerMessageClass',\n    },\n    process: {\n      bean: 'process',\n      concurrency: true,\n    },\n    delivery: {\n      bean: 'delivery',\n      concurrency: true,\n    },\n    push: {\n      bean: 'push',\n      concurrency: true,\n    },\n    pushDirect: {\n      bean: 'pushDirect',\n      concurrency: true,\n    },\n  };\n\n  // broadcasts\n  config.broadcasts = {\n    socketEmit: {\n      bean: 'socketEmit',\n    },\n  };\n\n  // message\n  config.message = {\n    sync: {\n      saveLimit: 20,\n    },\n  };\n\n  return config;\n};\n","// error code should start from 1001\nmodule.exports = {};\n","module.exports = {};\n","module.exports = {\n  'zh-cn': require('./locale/zh-cn.js'),\n};\n","module.exports = app => {\n  const messageSystem = {\n    info: {\n      title: 'Message System',\n      persistence: false,\n    },\n  };\n  return messageSystem;\n};\n","module.exports = app => {\n  const schemas = {};\n  return schemas;\n};\n","module.exports = app => {\n  class IOController extends app.Controller {\n    async subscribe() {\n      const res = await this.service.io.subscribe({\n        subscribes: this.ctx.request.body.subscribes,\n        socketId: this.ctx.request.body.socketId,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async unsubscribe() {\n      const res = await this.service.io.unsubscribe({\n        subscribes: this.ctx.request.body.subscribes,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n  }\n  return IOController;\n};\n","module.exports = app => {\n  class MessageController extends app.Controller {\n    async offset() {\n      const res = await this.ctx.service.message.offset({\n        messageClass: this.ctx.request.body.messageClass,\n        options: this.ctx.request.body.options,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async select() {\n      const options = this.ctx.request.body.options;\n      options.page = this.ctx.bean.util.page(options.page);\n      const items = await this.ctx.service.message.select({\n        messageClass: this.ctx.request.body.messageClass,\n        options,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.successMore(items, options.page.index, options.page.size);\n    }\n\n    async count() {\n      const options = this.ctx.request.body.options;\n      const count = await this.ctx.service.message.count({\n        messageClass: this.ctx.request.body.messageClass,\n        options,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(count);\n    }\n\n    async setRead() {\n      const res = await this.ctx.service.message.setRead({\n        messageClass: this.ctx.request.body.messageClass,\n        messageIds: this.ctx.request.body.messageIds,\n        all: this.ctx.request.body.all,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async delete() {\n      const res = await this.ctx.service.message.delete({\n        messageIds: this.ctx.request.body.messageIds,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n  }\n  return MessageController;\n};\n","module.exports = app => {\n  class MessageClassController extends app.Controller {\n    async messageClass() {\n      const res = await this.ctx.service.messageClass.messageClass({\n        messageClass: this.ctx.request.body.messageClass,\n      });\n      this.ctx.success(res);\n    }\n  }\n  return MessageClassController;\n};\n","const io = require('./controller/io.js');\nconst messageClass = require('./controller/messageClass.js');\nconst message = require('./controller/message.js');\n\nmodule.exports = app => {\n  const controllers = {\n    io,\n    messageClass,\n    message,\n  };\n  return controllers;\n};\n","const config = require('./config/config.js');\nconst locales = require('./config/locales.js');\nconst errors = require('./config/errors.js');\nconst IOMessageBaseFn = require('./bean/local.ioMessageBase.js');\nconst IOChannelBaseFn = require('./common/ioChannelBase.js');\n\nmodule.exports = app => {\n  // base\n  app.meta.IOMessageBase = IOMessageBaseFn;\n  app.meta.IOChannelBase = IOChannelBaseFn;\n\n  // beans\n  const beans = require('./beans.js')(app);\n  // routes\n  const routes = require('./routes.js')(app);\n  // controllers\n  const controllers = require('./controllers.js')(app);\n  // services\n  const services = require('./services.js')(app);\n  // models\n  const models = require('./models.js')(app);\n  // meta\n  const meta = require('./meta.js')(app);\n\n  return {\n    beans,\n    routes,\n    controllers,\n    services,\n    models,\n    config,\n    locales,\n    errors,\n    meta,\n  };\n};\n","module.exports = app => {\n  const schemas = require('./config/validation/schemas.js')(app);\n  // socketio\n  const socketioMessageSystem = require('./config/socketio/messageSystem.js')(app);\n  const meta = {\n    base: {\n      atoms: {},\n    },\n    validation: {\n      validators: {},\n      keywords: {},\n      schemas: {},\n    },\n    socketio: {\n      messages: {\n        messageSystem: socketioMessageSystem,\n      },\n    },\n  };\n  return meta;\n};\n","module.exports = app => {\n  class Message extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aSocketIOMessage', options: { disableDeleted: false } });\n    }\n  }\n  return Message;\n};\n","module.exports = app => {\n  class MessageClass extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aSocketIOMessageClass', options: { disableDeleted: false } });\n    }\n  }\n  return MessageClass;\n};\n","module.exports = app => {\n  class MessageSync extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aSocketIOMessageSync', options: { disableDeleted: false } });\n    }\n  }\n  return MessageSync;\n};\n","const messageClass = require('./model/messageClass.js');\nconst message = require('./model/message.js');\nconst messageSync = require('./model/messageSync.js');\n\nmodule.exports = app => {\n  const models = {\n    messageClass,\n    message,\n    messageSync,\n  };\n  return models;\n};\n","module.exports = app => {\n  const routes = [\n    // io\n    {\n      method: 'post',\n      path: 'subscribe',\n      controller: 'io',\n      meta: {\n        auth: { user: true },\n        right: { enableAuthOpen: true },\n      },\n    },\n    {\n      method: 'post',\n      path: 'unsubscribe',\n      controller: 'io',\n      meta: {\n        auth: { user: true },\n        right: { enableAuthOpen: true },\n      },\n    },\n    // messageClass\n    { method: 'post', path: 'messageClass/messageClass', controller: 'messageClass', meta: { auth: { user: true } } },\n    // message\n    { method: 'post', path: 'message/offset', controller: 'message', meta: { auth: { user: true } } },\n    { method: 'post', path: 'message/select', controller: 'message', meta: { auth: { user: true } } },\n    { method: 'post', path: 'message/count', controller: 'message', meta: { auth: { user: true } } },\n    { method: 'post', path: 'message/setRead', controller: 'message', meta: { auth: { user: true } } },\n    { method: 'post', path: 'message/delete', controller: 'message', meta: { auth: { user: true } } },\n  ];\n  return routes;\n};\n","module.exports = app => {\n  class IO extends app.Service {\n    async subscribe({ subscribes, socketId, user }) {\n      return await this.ctx.bean.io.subscribe({ subscribes, socketId, user });\n    }\n\n    async unsubscribe({ subscribes, user }) {\n      return await this.ctx.bean.io.unsubscribe({ subscribes, user });\n    }\n  }\n\n  return IO;\n};\n","module.exports = app => {\n  class Message extends app.Service {\n    async offset({ messageClass, options, user }) {\n      return await this.ctx.bean.io.message.offset({ messageClass, options, user });\n    }\n\n    async select({ messageClass, options, user }) {\n      return await this.ctx.bean.io.message.select({ messageClass, options, user });\n    }\n\n    async count({ messageClass, options, user }) {\n      return await this.ctx.bean.io.message.count({ messageClass, options, user });\n    }\n\n    async setRead({ messageClass, messageIds, all, user }) {\n      return await this.ctx.bean.io.message.setRead({ messageClass, messageIds, all, user });\n    }\n\n    async delete({ messageIds, user }) {\n      return await this.ctx.bean.io.message.delete({ messageIds, user });\n    }\n  }\n\n  return Message;\n};\n","module.exports = app => {\n  class MessageClass extends app.Service {\n    async messageClass({ messageClass }) {\n      return await this.ctx.bean.io.messageClass.get(messageClass);\n    }\n  }\n\n  return MessageClass;\n};\n","const io = require('./service/io.js');\nconst messageClass = require('./service/messageClass.js');\nconst message = require('./service/message.js');\n\nmodule.exports = app => {\n  const services = {\n    io,\n    messageClass,\n    message,\n  };\n  return services;\n};\n","module.exports = require(\"require3\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(421);\n",""],"names":[],"sourceRoot":""}