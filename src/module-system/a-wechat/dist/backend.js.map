{"version":3,"sources":["webpack://egg-born-module-a-wechat/./backend/src/bean/bean.wechat.js","webpack://egg-born-module-a-wechat/./backend/src/bean/event.accountMigration.js","webpack://egg-born-module-a-wechat/./backend/src/bean/event.loginInfo.js","webpack://egg-born-module-a-wechat/./backend/src/bean/middleware.inWechat.js","webpack://egg-born-module-a-wechat/./backend/src/bean/version.manager.js","webpack://egg-born-module-a-wechat/./backend/src/beans.js","webpack://egg-born-module-a-wechat/./backend/src/common/authProviderScenes.js","webpack://egg-born-module-a-wechat/./backend/src/common/wechatHelper.js","webpack://egg-born-module-a-wechat/./backend/src/common/wechatUtils.js","webpack://egg-born-module-a-wechat/./backend/src/config/config.js","webpack://egg-born-module-a-wechat/./backend/src/config/errors.js","webpack://egg-born-module-a-wechat/./backend/src/config/locale/zh-cn.js","webpack://egg-born-module-a-wechat/./backend/src/config/locales.js","webpack://egg-born-module-a-wechat/./backend/src/controller/authMini.js","webpack://egg-born-module-a-wechat/./backend/src/controller/jssdk.js","webpack://egg-born-module-a-wechat/./backend/src/controller/message.js","webpack://egg-born-module-a-wechat/./backend/src/controller/messageMini.js","webpack://egg-born-module-a-wechat/./backend/src/controllers.js","webpack://egg-born-module-a-wechat/./backend/src/main.js","webpack://egg-born-module-a-wechat/./backend/src/meta.js","webpack://egg-born-module-a-wechat/./backend/src/model/wechatUser.js","webpack://egg-born-module-a-wechat/./backend/src/models.js","webpack://egg-born-module-a-wechat/./backend/src/passport/auth.js","webpack://egg-born-module-a-wechat/./backend/src/routes.js","webpack://egg-born-module-a-wechat/./backend/src/service/authMini.js","webpack://egg-born-module-a-wechat/./backend/src/service/jssdk.js","webpack://egg-born-module-a-wechat/./backend/src/service/message.js","webpack://egg-born-module-a-wechat/./backend/src/service/messageMini.js","webpack://egg-born-module-a-wechat/./backend/src/services.js","webpack://egg-born-module-a-wechat/external \"crypto\"","webpack://egg-born-module-a-wechat/external \"require3\"","webpack://egg-born-module-a-wechat/webpack/bootstrap","webpack://egg-born-module-a-wechat/webpack/startup"],"names":[],"mappings":";;;;;;AAAA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,sDAAsD,mBAAmB;AACzE;AACA;AACA,iBAAiB;AACjB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,KAAK;AACjD;AACA,OAAO;AACP;AACA,4CAA4C,KAAK;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA,OAAO;AACP;AACA,gDAAgD,KAAK;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,wBAAwB;AAC1E;AACA,OAAO;AACP;AACA,kDAAkD,wBAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACbA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACnDA,uBAAuB,mBAAO,CAAC,GAA2B;AAC1D,uBAAuB,mBAAO,CAAC,GAA2B;AAC1D,8BAA8B,mBAAO,CAAC,GAAkC;AACxE,2BAA2B,mBAAO,CAAC,GAA+B;AAClE,mBAAmB,mBAAO,CAAC,GAAuB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW,KAAK,gCAAgC;AAClE;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;AC9CA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA,2BAA2B,mBAAO,CAAC,GAAyB;;AAE5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,2CAA2C;AACrE;AACA,yDAAyD,0BAA0B;AACnF;AACA,sDAAsD,0BAA0B;AAChF;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC,sDAAsD;AAC1F;AACA;AACA;;AAEA,6BAA6B,0BAA0B;AACvD;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,2CAA2C,2BAA2B;AACtE;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,GAAG,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,gJAAgJ,OAAO;AACvJ;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+HAA+H,QAAQ;AACvI;AACA;AACA;AACA,kCAAkC,wCAAwC;AAC1E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC5KA,eAAe,mBAAO,CAAC,GAAQ;AAC/B,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA,GAAG;AACH,kBAAkB,gEAAgE;AAClF,sCAAsC,oCAAoC;AAC1E;AACA;AACA,KAAK;AACL,GAAG;AACH,YAAY,uDAAuD;AACnE,+BAA+B,4BAA4B;AAC3D,GAAG;AACH;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACRA;AACA,WAAW,mBAAO,CAAC,EAAmB;AACtC;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;ACVA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA,oBAAoB,mBAAO,CAAC,GAA0B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yCAAyC;AAC1F;AACA;AACA;AACA;AACA,OAAO;AACP,kDAAkD,yCAAyC;AAC3F;AACA;AACA,iEAAiE,qBAAqB;AACtF;AACA;AACA,SAAS;AACT,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA,OAAO;AACP,+DAA+D,+DAA+D;AAC9H;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,cAAc;AACd;;AAEA,6BAA6B,yCAAyC;AACtE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA,OAAO;AACP,+DAA+D,+DAA+D;AAC9H;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7FA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA,oBAAoB,mBAAO,CAAC,GAA0B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yCAAyC;AAC1F;AACA;AACA;AACA;AACA,OAAO;AACP,kDAAkD,yCAAyC;AAC3F;AACA,kDAAkD,4BAA4B;AAC9E;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA,OAAO;AACP,+DAA+D,+DAA+D;AAC9H;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,cAAc;AACd;;AAEA,6BAA6B,yCAAyC;AACtE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,+DAA+D,+DAA+D;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1EA,gBAAgB,mBAAO,CAAC,GAAyB;AACjD,cAAc,mBAAO,CAAC,GAAuB;AAC7C,oBAAoB,mBAAO,CAAC,GAA6B;AACzD,iBAAiB,mBAAO,CAAC,GAA0B;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA,eAAe,mBAAO,CAAC,EAAoB;AAC3C,gBAAgB,mBAAO,CAAC,EAAqB;AAC7C,eAAe,mBAAO,CAAC,GAAoB;;AAE3C;AACA;AACA,gBAAgB,mBAAO,CAAC,GAAY;AACpC;AACA,iBAAiB,mBAAO,CAAC,GAAa;AACtC;AACA,sBAAsB,mBAAO,CAAC,EAAkB;AAChD;AACA,mBAAmB,mBAAO,CAAC,GAAe;AAC1C;AACA,iBAAiB,mBAAO,CAAC,GAAa;AACtC;AACA,eAAe,mBAAO,CAAC,GAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7BA,eAAe,mBAAO,CAAC,GAAoB;;AAE3C;AACA;AACA;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA,oBAAoB;AACpB,kBAAkB;AAClB,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;;;;;;;AC1BA;AACA;AACA;AACA,kBAAkB,iCAAiC,wBAAwB,EAAE;AAC7E;AACA;AACA;AACA;;;;;;;;ACPA,mBAAmB,mBAAO,CAAC,GAAuB;;AAElD;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA,uBAAuB,mBAAO,CAAC,GAA2B;AAC1D,2BAA2B,mBAAO,CAAC,GAAiC;;AAEpE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,kBAAkB;AAClB,SAAS;AACT;AACA,0CAA0C,uBAAuB,GAAG,OAAO;AAC3E;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,0CAA0C,uBAAuB,GAAG,OAAO;AAC3E;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5GA;AACA;AACA;AACA,KAAK,qEAAqE,QAAQ,gBAAgB,EAAE,EAAE;AACtG,KAAK,sEAAsE,QAAQ,gBAAgB,EAAE,EAAE;AACvG;AACA,KAAK,8DAA8D;;AAEnE;AACA,KAAK,+FAA+F,QAAQ,gBAAgB,EAAE,EAAE;AAChI,KAAK,gGAAgG,QAAQ,gBAAgB,EAAE,EAAE;AACjI;AACA,KAAK,iEAAiE;AACtE;AACA;AACA;;;;;;;;ACfA,uBAAuB,mBAAO,CAAC,GAA2B;;AAE1D;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB,MAAM,qBAAqB;AACzF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACrDA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AChBA,uBAAuB,mBAAO,CAAC,GAA2B;;AAE1D;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA,8CAA8C,wCAAwC;AACtF,SAAS;AACT,gDAAgD,wCAAwC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA,0BAA0B,kBAAkB;AAC5C;AACA,+DAA+D,SAAS;AACxE;AACA;AACA,yCAAyC,oCAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,kBAAkB;AAC9C;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC1EA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,OAAO;AACP;AACA;;AAEA;AACA;;;;;;;;ACdA,gBAAgB,mBAAO,CAAC,GAAsB;AAC9C,cAAc,mBAAO,CAAC,GAAoB;AAC1C,oBAAoB,mBAAO,CAAC,EAA0B;AACtD,iBAAiB,mBAAO,CAAC,GAAuB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACbA,mC;;;;;;;;ACAA,qC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UCtBA;UACA;UACA;UACA","file":"backend.js","sourcesContent":["const require3 = require('require3');\nconst WechatAPI = require3('@zhennann/co-wechat-api');\n\nmodule.exports = function (ctx) {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n\n  return function () {\n    return new Proxy(\n      {},\n      {\n        get(obj, prop) {\n          if (obj[prop]) return obj[prop];\n          if (prop === 'app') {\n            // app\n            obj[prop] = _createWechatApiApp();\n          } else if (prop === 'mini') {\n            // mini\n            obj[prop] = new Proxy(\n              {},\n              {\n                get(obj, prop) {\n                  if (!obj[prop]) {\n                    obj[prop] = _createWechatApiMini({ sceneShort: prop });\n                  }\n                  return obj[prop];\n                },\n              }\n            );\n          } else if (prop === 'util') {\n            // util\n            obj[prop] = _createWechatApiUtil();\n          }\n          return obj[prop];\n        },\n      }\n    );\n  };\n\n  function _createWechatApiApp() {\n    // config\n    const config = ctx.config.module(moduleInfo.relativeName).account.public;\n    // api\n    const api = new WechatAPI(\n      config.appID,\n      config.appSecret,\n      async function () {\n        const cacheKey = 'wechat-token';\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function (token) {\n        const cacheKey = 'wechat-token';\n        if (token) {\n          await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n        } else {\n          await ctx.cache.db.module(moduleInfo.relativeName).remove(cacheKey);\n        }\n      }\n    );\n    // registerTicketHandle\n    api.registerTicketHandle(\n      async function (type) {\n        const cacheKey = `wechat-jsticket:${type}`;\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function (type, token) {\n        const cacheKey = `wechat-jsticket:${type}`;\n        if (token) {\n          await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n        } else {\n          await ctx.cache.db.module(moduleInfo.relativeName).remove(cacheKey);\n        }\n      }\n    );\n    // ready\n    return api;\n  }\n\n  function _createWechatApiMini({ sceneShort }) {\n    // config\n    const config = ctx.config.module(moduleInfo.relativeName).account.minis[sceneShort];\n    // api\n    const api = new WechatAPI(\n      config.appID,\n      config.appSecret,\n      async function () {\n        const cacheKey = 'wechatmini-token';\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function (token) {\n        const cacheKey = 'wechatmini-token';\n        if (token) {\n          await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n        } else {\n          await ctx.cache.db.module(moduleInfo.relativeName).remove(cacheKey);\n        }\n      }\n    );\n    // registerTicketHandle\n    api.registerTicketHandle(\n      async function (type) {\n        const cacheKey = `wechatmini-jsticket:${type}`;\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function (type, token) {\n        const cacheKey = `wechatmini-jsticket:${type}`;\n        if (token) {\n          await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n        } else {\n          await ctx.cache.db.module(moduleInfo.relativeName).remove(cacheKey);\n        }\n      }\n    );\n    // registerSessionKeyHandle\n    api.registerSessionKeyHandle(\n      async function () {\n        const cacheKey = `wechatmini-sessionKey:${ctx.state.user.agent.id}`;\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function (sessionKey) {\n        const cacheKey = `wechatmini-sessionKey:${ctx.state.user.agent.id}`;\n        await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, sessionKey);\n      }\n    );\n    // ready\n    return api;\n  }\n\n  function _createWechatApiUtil() {\n    return {\n      // scene: empty/wechat/wechatweb/wechatmini/xxx,xxx,xxx\n      in(scene) {\n        // scene\n        if (!scene) scene = 'wechat';\n        if (typeof scene === 'string') scene = scene.split(',');\n        // provider\n        const provider = ctx.state.user && ctx.state.user.provider;\n        if (!provider || provider.module !== moduleInfo.relativeName) return false;\n        // find any match\n        for (const item of scene) {\n          const ok = provider.providerName === item || (item === 'wechatmini' && provider.providerName.indexOf(item) > -1);\n          if (ok) return true;\n        }\n        // not found\n        return false;\n      },\n    };\n  }\n};\n","module.exports = ctx => {\n  // const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class eventBean {\n    async execute(context, next) {\n      const data = context.data;\n      // aWechatUser\n      await ctx.model.query('update aWechatUser a set a.userId=? where a.iid=? and a.userId=?', [data.userIdTo, ctx.instance.id, data.userIdFrom]);\n      // next\n      await next();\n    }\n  }\n\n  return eventBean;\n};\n","const require3 = require('require3');\nconst extend = require3('extend2');\n\nmodule.exports = ctx => {\n  class eventBean {\n    async execute(context, next) {\n      const info = context.data.info;\n      const provider = info.user && info.user.provider;\n      if (provider && provider.module === 'a-wechat') {\n        info.config = extend(true, info.config, {\n          modules: {\n            'a-base': {\n              account: {\n                needActivation: false,\n              },\n            },\n          },\n        });\n      }\n      // next\n      await next();\n    }\n  }\n\n  return eventBean;\n};\n","module.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class Middleware {\n    async execute(options, next) {\n      if (!ctx.bean.wechat.util.in(options.scene)) return ctx.throw.module(moduleInfo.relativeName, 1001);\n      // next\n      await next();\n    }\n  }\n  return Middleware;\n};\n","module.exports = app => {\n  class Version extends app.meta.BeanBase {\n    async update(options) {\n      if (options.version === 1) {\n        // create table: aWechatUser\n        const sql = `\n          CREATE TABLE aWechatUser (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            scene int(11) DEFAULT '0',\n            userId int(11) DEFAULT '0',\n            openid varchar(255) DEFAULT NULL,\n            unionid varchar(255) DEFAULT NULL,\n            nickname varchar(50) DEFAULT NULL,\n            subscribe int(11) DEFAULT '0',\n            sex int(11) DEFAULT '0',\n            language varchar(50) DEFAULT NULL,\n            city varchar(50) DEFAULT NULL,\n            province varchar(50) DEFAULT NULL,\n            country varchar(50) DEFAULT NULL,\n            headimgurl varchar(255) DEFAULT NULL,\n            subscribe_time int(11) DEFAULT '0',\n            remark varchar(255) DEFAULT NULL,\n            groupid int(11) DEFAULT '0',\n            subscribe_scene varchar(50) DEFAULT NULL,\n            qr_scene int(11) DEFAULT '0',\n            qr_scene_str varchar(255) DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n      }\n\n      if (options.version === 2) {\n        const sql = `\n          ALTER TABLE aWechatUser\n            CHANGE COLUMN scene scene varchar(255) DEFAULT NULL\n        `;\n        await this.ctx.model.query(sql);\n      }\n    }\n\n    async init(options) {}\n\n    async test() {}\n  }\n\n  return Version;\n};\n","const versionManager = require('./bean/version.manager.js');\nconst eventLoginInfo = require('./bean/event.loginInfo.js');\nconst eventAccountMigration = require('./bean/event.accountMigration.js');\nconst middlewareInWechat = require('./bean/middleware.inWechat.js');\nconst beanWechat = require('./bean/bean.wechat.js');\n\nmodule.exports = app => {\n  const beans = {\n    // version\n    'version.manager': {\n      mode: 'app',\n      bean: versionManager,\n    },\n    // event\n    'event.loginInfo': {\n      mode: 'ctx',\n      bean: eventLoginInfo,\n    },\n    'event.accountMigration': {\n      mode: 'ctx',\n      bean: eventAccountMigration,\n    },\n    // middleware\n    'middleware.inWechat': {\n      mode: 'ctx',\n      bean: middlewareInWechat,\n    },\n    // global\n    wechat: {\n      mode: 'ctx',\n      bean: beanWechat,\n      global: true,\n    },\n  };\n  return beans;\n};\n","const _scenes = {\n  wechat: {\n    scene: 'wechat',\n    authProvider: 'wechat',\n    title: 'Wechat Public',\n    client: 'wechat',\n    configKey: 'public',\n    scope: 'snsapi_userinfo',\n  },\n  wechatweb: {\n    scene: 'wechatweb',\n    authProvider: 'wechatweb',\n    title: 'Wechat Web',\n    client: 'wechatweb',\n    configKey: 'web',\n    scope: 'snsapi_login',\n  },\n  wechatmini: {\n    scene: 'wechatmini',\n    authProvider: 'wechatmini',\n    title: 'Wechat Miniprogram',\n    scope: 'snsapi_userinfo',\n  },\n};\n\nfunction _upperCaseFirstChar(str) {\n  if (!str) return '';\n  return str.substring(0, 1).toUpperCase() + str.substring(1);\n}\n\nmodule.exports = {\n  scenes: _scenes,\n  getScene(scene) {\n    if (scene.indexOf('wechatmini') > -1) {\n      const sceneShort = scene.substr('wechatmini'.length);\n      // wechatmini\n      const base = _scenes.wechatmini;\n      return {\n        scene,\n        authProvider: scene,\n        title: `${base.title} - ${_upperCaseFirstChar(sceneShort)}`,\n      };\n    }\n    // else\n    return _scenes[scene];\n  },\n};\n","const require3 = require('require3');\nconst bb = require3('bluebird');\nconst extend = require3('extend2');\nconst authProviderScenes = require('./authProviderScenes.js');\n\nmodule.exports = function (ctx) {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class WechatHelper {\n    getSceneInfo(scene) {\n      return authProviderScenes.getScene(scene);\n    }\n\n    // scene: wechat/wechatweb/wechatmini\n    async verifyAuthUser({ scene, openid, userInfo, cbVerify, state }) {\n      // ensure wechat user\n      const userWechatId = await this._ensureWechatUser({ scene, openid, userInfo });\n      // ensure auth user\n      const profileUser = await this._ensureAuthUser({ scene, openid, userInfo });\n      // verify\n      let verifyUser;\n      if (!cbVerify) {\n        verifyUser = await ctx.bean.user.verify({ state, profileUser });\n        await ctx.login(verifyUser);\n      } else {\n        verifyUser = await bb.fromCallback(cb => {\n          cbVerify(profileUser, cb);\n        });\n      }\n      // update wechat userId\n      await this._updateWechatUser({ userId: verifyUser.agent.id, userWechatId, userInfo });\n      // ok\n      return verifyUser;\n    }\n\n    async _ensureWechatUser({ scene, openid, userInfo }) {\n      let userWechatId;\n      // wechat user\n      let userWechat = await ctx.model.wechatUser.get({ openid });\n      const exists = !!userWechat;\n      if (!userWechat) {\n        userWechat = {};\n      } else {\n        userWechatId = userWechat.id;\n        delete userWechat.createdAt;\n        delete userWechat.updatedAt;\n        delete userWechat.deleted;\n        delete userWechat.iid;\n        delete userWechat.userId;\n      }\n      // check fields\n      let needUpdate = false;\n      const fields = [\n        'scene',\n        'openid',\n        'unionid',\n        'nickname',\n        'subscribe',\n        'sex',\n        'language',\n        'city',\n        'province',\n        'country',\n        'headimgurl',\n        'subscribe_time',\n        'remark',\n        'groupid',\n        'subscribe_scene',\n        'qr_scene',\n        'qr_scene_str',\n      ];\n      userInfo.scene = scene;\n      for (const field of fields) {\n        if (userInfo[field] === undefined || userInfo[field] === userWechat[field]) {\n          delete userWechat[field];\n        } else {\n          userWechat[field] = userInfo[field];\n          needUpdate = true;\n        }\n      }\n      // update\n      if (needUpdate) {\n        if (!exists) {\n          const res = await ctx.model.wechatUser.insert(userWechat);\n          userWechatId = res.insertId;\n        } else {\n          await ctx.model.wechatUser.update(userWechat);\n        }\n      }\n      // ok\n      return userWechatId;\n    }\n\n    async _updateWechatUser({ userId, userWechatId, userInfo }) {\n      const unionid = userInfo.unionid || '';\n      if (unionid) {\n        // update all\n        await ctx.model.query('update aWechatUser a set a.userId=? where a.deleted=0 and a.iid=? and a.unionid=?', [userId, ctx.instance.id, unionid]);\n      } else {\n        // update this\n        await ctx.model.wechatUser.update({ id: userWechatId, userId });\n      }\n    }\n\n    // profileId : unionid:openid\n    async _ensureAuthUser({ scene, openid, userInfo }) {\n      // model auth\n      const modelAuth = ctx.model.module('a-base').auth;\n      //\n      const sceneInfo = this.getSceneInfo(scene);\n      const unionid = userInfo.unionid || '';\n      const profileId = `${unionid}:${openid}`;\n      const profileUser = {\n        module: moduleInfo.relativeName,\n        provider: sceneInfo.authProvider,\n        profileId,\n        profile: {\n          userName: userInfo.nickname,\n          realName: userInfo.nickname,\n          avatar: userInfo.headimgurl,\n          profile: userInfo,\n        },\n      };\n      // provider\n      const providerItem = await ctx.bean.user.getAuthProvider({\n        module: moduleInfo.relativeName,\n        providerName: sceneInfo.authProvider,\n      });\n      // check auth\n      let authId;\n      let authUserId;\n      const authItems = await ctx.model.query(`select * from aAuth a where a.deleted=0 and a.iid=? and a.providerId=? and a.profileId like '%:${openid}'`, [ctx.instance.id, providerItem.id]);\n      const authItem = authItems[0];\n      if (!authItem) {\n        // always set avatar empty\n        const _profile = extend(true, {}, profileUser.profile);\n        delete _profile.avatar;\n        // insert auth\n        const res = await modelAuth.insert({\n          providerId: providerItem.id,\n          profileId,\n          profile: JSON.stringify(_profile),\n        });\n        authId = res.insertId;\n      } else {\n        // hold old avatar empty\n        const _profile = extend(true, {}, profileUser.profile);\n        const _profileOld = JSON.parse(authItem.profile);\n        _profile.avatar = _profileOld.avatar;\n        // always update\n        await modelAuth.update({\n          id: authItem.id,\n          profileId,\n          profile: JSON.stringify(_profile),\n        });\n        authId = authItem.id;\n        authUserId = authItem.userId;\n      }\n      // check if has userId for unionid\n      if (unionid) {\n        const _authOthers = await ctx.model.query(`select * from aAuth a where a.deleted=0 and a.iid=? and a.profileId like '${unionid}:%' and a.id<>?`, [ctx.instance.id, authId]);\n        const _authOther = _authOthers[0];\n        if (_authOther && _authOther.userId !== authUserId) {\n          // update userId for this auth\n          await modelAuth.update({ id: authId, userId: _authOther.userId });\n        }\n      }\n      // ready\n      return profileUser;\n    }\n  }\n\n  return WechatHelper;\n};\n","const crypto = require('crypto');\nconst require3 = require('require3');\nconst bb = require3('bluebird');\nconst xml2js = require3('xml2js');\n\nmodule.exports = {\n  createNonceStr() {\n    return Math.random().toString(36).substr(2, 15);\n  },\n  createTimestamp() {\n    return '' + Math.floor(Date.now() / 1000);\n  },\n  calcSignature({ options, join = '', hash = 'sha1' }) {\n    const hashsum = crypto.createHash(hash);\n    hashsum.update(options.join(join));\n    return hashsum.digest('hex');\n  },\n  async parseXML({ xml, trim = true, explicitArray = false, explicitRoot = false }) {\n    const parser = new xml2js.Parser({ trim, explicitArray, explicitRoot });\n    return await bb.fromCallback(cb => {\n      parser.parseString(xml, cb);\n    });\n  },\n  buildXML({ xml, cdata = true, headless = true, rootName = 'xml' }) {\n    return new xml2js.Builder({ cdata, headless, rootName }).buildObject(xml);\n  },\n};\n","const jsApiList = [\n  'checkJsApi',\n  'updateAppMessageShareData',\n  'updateTimelineShareData',\n  'onMenuShareWeibo',\n  // 'onMenuShareTimeline',\n  // 'onMenuShareAppMessage',\n  // 'onMenuShareQQ',\n  // 'onMenuShareQZone',\n  'hideMenuItems',\n  'showMenuItems',\n  'hideAllNonBaseMenuItem',\n  'showAllNonBaseMenuItem',\n  'translateVoice',\n  'startRecord',\n  'stopRecord',\n  'onRecordEnd',\n  'playVoice',\n  'pauseVoice',\n  'stopVoice',\n  'uploadVoice',\n  'downloadVoice',\n  'chooseImage',\n  'previewImage',\n  'uploadImage',\n  'downloadImage',\n  'getNetworkType',\n  'openLocation',\n  'getLocation',\n  'hideOptionMenu',\n  'showOptionMenu',\n  'closeWindow',\n  'scanQRCode',\n  'chooseWXPay',\n  'openProductSpecificView',\n  'addCard',\n  'chooseCard',\n  'openCard',\n];\n\nmodule.exports = appInfo => {\n  const config = {};\n\n  // middlewares\n  config.middlewares = {\n    inWechat: {\n      bean: 'inWechat',\n      global: false,\n      dependencies: 'instance',\n    },\n  };\n\n  // account\n  config.account = {};\n\n  // account.public\n  config.account.public = {\n    appID: '',\n    appSecret: '',\n    token: appInfo.name,\n    encodingAESKey: '',\n    message: {\n      reply: {\n        default: 'You are welcome!',\n        subscribe: 'You are subscribed!',\n      },\n    },\n    jssdk: {\n      // debug: true,\n      debug: false,\n      jsApiList,\n    },\n  };\n\n  // account.web\n  config.account.web = {\n    appID: '',\n    appSecret: '',\n  };\n\n  // account.minis\n  config.account.minis = {\n    default: {\n      appID: '',\n      appSecret: '',\n      token: appInfo.name,\n      encodingAESKey: '',\n    },\n  };\n\n  return config;\n};\n","// error code should start from 1001\nmodule.exports = {\n  1001: 'Not In Wechat',\n  1002: 'Not In Wechat Miniprogram',\n};\n","module.exports = {\n  Wechat: '微信',\n  'Wechat Public': '微信公众号',\n  'Wechat Miniprogram': '微信小程序',\n  'Wechat Miniprogram - Default': '微信小程序 - 默认',\n  'Wechat Web': '微信Web',\n  'Not In Wechat': '不在微信内部',\n  'Not In Wechat Miniprogram': '不在微信小程序内部',\n};\n","module.exports = {\n  'zh-cn': require('./locale/zh-cn.js'),\n};\n","module.exports = app => {\n  class AuthMiniController extends app.Controller {\n    async login() {\n      const res = await this.service.authMini.login({\n        scene: this.ctx.request.body.scene,\n        code: this.ctx.request.body.code,\n        detail: this.ctx.request.body.detail,\n      });\n      this.ctx.success(res);\n    }\n  }\n  return AuthMiniController;\n};\n","module.exports = app => {\n  class JSSDKController extends app.Controller {\n    async jsconfig() {\n      const res = await this.service.jssdk.jsconfig({\n        url: this.ctx.request.body.url,\n      });\n      this.ctx.success(res);\n    }\n  }\n  return JSSDKController;\n};\n","const require3 = require('require3');\nconst WechatCrypto = require3('wechat-crypto');\nconst wechatUtils = require('../common/wechatUtils.js');\n\nmodule.exports = app => {\n  class MessageController extends app.Controller {\n    async index() {\n      // query\n      const query = this.ctx.query;\n      // config\n      const config = this.ctx.config.account.public;\n      // encrypted\n      const encrypted = query.encrypt_type === 'aes';\n      // wechat crypto\n      const wechatCrypto = encrypted ? new WechatCrypto(config.token, config.encodingAESKey, config.appID) : null;\n      // parse\n      let messageIn;\n      if (this.ctx.method === 'GET') {\n        messageIn = await this._parseMessageGet({ query, config, encrypted, wechatCrypto });\n        // ok\n        this.ctx.status = 200;\n        this.ctx.type = 'text/plain';\n        this.ctx.body = messageIn.echostr;\n      } else {\n        messageIn = await this._parseMessagePost({ query, config, encrypted, wechatCrypto });\n        // handle\n        let resXML;\n        const messageOut = await this.ctx.service.message.index({ message: messageIn });\n        if (!messageOut) {\n          resXML = '';\n        } else {\n          resXML = wechatUtils.buildXML({ xml: messageOut });\n          if (encrypted) {\n            const wrap = {};\n            wrap.Encrypt = wechatCrypto.encrypt(resXML);\n            wrap.TimeStamp = wechatUtils.createTimestamp();\n            wrap.Nonce = wechatUtils.createNonceStr();\n            wrap.MsgSignature = wechatCrypto.getSignature(wrap.TimeStamp, wrap.Nonce, wrap.Encrypt);\n            resXML = wechatUtils.buildXML({ xml: wrap });\n          }\n        }\n        // ok\n        this.ctx.status = 200;\n        this.ctx.type = 'text/xml';\n        this.ctx.body = resXML;\n      }\n    }\n\n    async _parseMessageGet({ query, config, encrypted, wechatCrypto }) {\n      // check if valid\n      let valid = false;\n      if (encrypted) {\n        valid = query.msg_signature === wechatCrypto.getSignature(query.timestamp, query.nonce, query.echostr);\n      } else {\n        valid = query.signature === wechatUtils.calcSignature({ options: [config.token, query.timestamp, query.nonce].sort() });\n      }\n      if (!valid) this.ctx.throw(401);\n      // decrypt\n      if (encrypted) {\n        const res = wechatCrypto.decrypt(query.echostr);\n        return { echostr: res.message };\n      }\n      return { echostr: query.echostr };\n    }\n\n    async _parseMessagePost({ query, config, encrypted, wechatCrypto }) {\n      // xml raw\n      let xmlRaw;\n      if (typeof this.ctx.request.body === 'string') {\n        xmlRaw = this.ctx.request.body;\n      } else {\n        const payload = await this.ctx.getPayload();\n        xmlRaw = payload.toString();\n      }\n      // parse xml\n      let xml = await wechatUtils.parseXML({ xml: xmlRaw });\n      // check if valid\n      let valid = false;\n      if (encrypted) {\n        valid = query.msg_signature === wechatCrypto.getSignature(query.timestamp, query.nonce, xml.Encrypt);\n      } else {\n        valid = query.signature === wechatUtils.calcSignature({ options: [config.token, query.timestamp, query.nonce].sort() });\n      }\n      if (!valid) this.ctx.throw(401);\n      // decrypt\n      if (encrypted) {\n        const res = wechatCrypto.decrypt(xml.Encrypt);\n        xml = await wechatUtils.parseXML({ xml: res.message });\n      }\n      return xml;\n    }\n  }\n  return MessageController;\n};\n","const require3 = require('require3');\nconst WechatCrypto = require3('wechat-crypto');\nconst wechatUtils = require('../common/wechatUtils.js');\n\nmodule.exports = app => {\n  class MessageMiniController extends app.Controller {\n    async index() {\n      // scene\n      let scene = this.ctx.params.scene || 'default';\n      // compatible with the old 'index'\n      if (scene === 'index') scene = 'default';\n      // query\n      const query = this.ctx.query;\n      // config\n      const config = this.ctx.config.account.minis[scene];\n      // encrypted\n      const encrypted = query.encrypt_type === 'aes';\n      // wechat crypto\n      const wechatCrypto = encrypted ? new WechatCrypto(config.token, config.encodingAESKey, config.appID) : null;\n      // parse\n      let messageIn;\n      if (this.ctx.method === 'GET') {\n        messageIn = await this._parseMessageGet({ query, config, encrypted, wechatCrypto });\n        // ok\n        this.ctx.status = 200;\n        this.ctx.type = 'text/plain';\n        this.ctx.body = messageIn.echostr;\n      } else {\n        messageIn = await this._parseMessagePost({ query, config, encrypted, wechatCrypto });\n        // handle\n        await this.ctx.service.messageMini.index({ scene, message: messageIn });\n        // ok\n        this.ctx.status = 200;\n        this.ctx.type = 'text/plain';\n        this.ctx.body = '';\n      }\n    }\n\n    async _parseMessageGet({ query, config, encrypted, wechatCrypto }) {\n      // check if valid\n      let valid = false;\n      if (encrypted) {\n        valid = query.msg_signature === wechatCrypto.getSignature(query.timestamp, query.nonce, query.echostr);\n      } else {\n        valid = query.signature === wechatUtils.calcSignature({ options: [config.token, query.timestamp, query.nonce].sort() });\n      }\n      if (!valid) this.ctx.throw(401);\n      // decrypt\n      if (encrypted) {\n        const res = wechatCrypto.decrypt(query.echostr);\n        return { echostr: res.message };\n      }\n      return { echostr: query.echostr };\n    }\n\n    async _parseMessagePost({ query, config, encrypted, wechatCrypto }) {\n      let messageIn = this.ctx.request.body;\n      // check if valid\n      let valid = false;\n      if (encrypted) {\n        valid = query.msg_signature === wechatCrypto.getSignature(query.timestamp, query.nonce, messageIn.Encrypt);\n      } else {\n        valid = query.signature === wechatUtils.calcSignature({ options: [config.token, query.timestamp, query.nonce].sort() });\n      }\n      if (!valid) this.ctx.throw(401);\n      // decrypt\n      if (encrypted) {\n        const res = wechatCrypto.decrypt(messageIn.Encrypt);\n        messageIn = JSON.parse(res.message);\n      }\n      return messageIn;\n    }\n  }\n  return MessageMiniController;\n};\n","const message = require('./controller/message.js');\nconst jssdk = require('./controller/jssdk.js');\nconst messageMini = require('./controller/messageMini.js');\nconst authMini = require('./controller/authMini.js');\n\nmodule.exports = app => {\n  const controllers = {\n    message,\n    jssdk,\n    messageMini,\n    authMini,\n  };\n  return controllers;\n};\n","const config = require('./config/config.js');\nconst locales = require('./config/locales.js');\nconst errors = require('./config/errors.js');\n\nmodule.exports = app => {\n  // beans\n  const beans = require('./beans.js')(app);\n  // routes\n  const routes = require('./routes.js')(app);\n  // controllers\n  const controllers = require('./controllers.js')(app);\n  // services\n  const services = require('./services.js')(app);\n  // models\n  const models = require('./models.js')(app);\n  // meta\n  const meta = require('./meta.js')(app);\n\n  return {\n    beans,\n    routes,\n    controllers,\n    services,\n    models,\n    config,\n    locales,\n    errors,\n    meta,\n  };\n};\n","const authFn = require('./passport/auth.js');\n\nmodule.exports = app => {\n  // const schemas = require('./config/validation/schemas.js')(app);\n  const meta = {\n    base: {\n      atoms: {},\n    },\n    validation: {\n      validators: {},\n      keywords: {},\n      schemas: {},\n    },\n    event: {\n      declarations: {\n        wechatMessage: 'Wechat Message',\n        wechatMessageMini: 'Miniprogram Message',\n      },\n      implementations: {\n        'a-base:loginInfo': 'loginInfo',\n        'a-base:accountMigration': 'accountMigration',\n      },\n    },\n    auth: authFn,\n  };\n  return meta;\n};\n","module.exports = app => {\n  class WechatUser extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aWechatUser', options: { disableDeleted: false } });\n    }\n  }\n  return WechatUser;\n};\n","const wechatUser = require('./model/wechatUser.js');\n\nmodule.exports = app => {\n  const models = {\n    wechatUser,\n  };\n  return models;\n};\n","const require3 = require('require3');\nconst strategy = require3('@zhennann/passport-wechat').Strategy;\nconst WechatHelperFn = require('../common/wechatHelper.js');\nconst authProviderScenes = require('../common/authProviderScenes.js');\n\nmodule.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n\n  function _createProvider(sceneInfo) {\n    const config = ctx.config.module(moduleInfo.relativeName).account[sceneInfo.configKey];\n    if (!config.appID || !config.appSecret) return null;\n    return {\n      meta: {\n        title: sceneInfo.title,\n        mode: 'redirect',\n        component: `button${sceneInfo.authProvider}`,\n      },\n      config: {\n        client: sceneInfo.client,\n        scope: sceneInfo.scope,\n      },\n      configFunctions: {\n        getConfig(ctx) {\n          const config = ctx.config.module(moduleInfo.relativeName).account[sceneInfo.configKey];\n          return { appID: config.appID, appSecret: config.appSecret };\n        },\n        getToken(ctx, openid, cb) {\n          const name = `wechat-webtoken:${sceneInfo.authProvider}:${openid}`;\n          ctx.cache.db\n            .module(moduleInfo.relativeName)\n            .get(name)\n            .then(token => {\n              cb(null, token);\n            })\n            .catch(cb);\n        },\n        saveToken(ctx, openid, token, cb) {\n          const name = `wechat-webtoken:${sceneInfo.authProvider}:${openid}`;\n          ctx.cache.db\n            .module(moduleInfo.relativeName)\n            .set(name, token, (token.expires_in - 10) * 1000)\n            .then(() => {\n              cb(null);\n            })\n            .catch(cb);\n        },\n      },\n      handler: app => {\n        return {\n          strategy,\n          callback: (req, accessToken, refreshToken, userInfo, expires_in, done) => {\n            const ctx = req.ctx;\n            const state = ctx.request.query.state || 'login';\n            const wechatHelper = new (WechatHelperFn(ctx))();\n            wechatHelper\n              .verifyAuthUser({\n                scene: sceneInfo.scene,\n                openid: userInfo.openid,\n                userInfo,\n                state,\n                cbVerify: (profileUser, cb) => {\n                  app.passport.doVerify(req, profileUser, cb);\n                },\n              })\n              .then(verifyUser => {\n                done(null, verifyUser);\n              })\n              .catch(done);\n          },\n        };\n      },\n    };\n  }\n\n  function _createProviderMini(sceneInfo, sceneShort) {\n    const config = ctx.config.module(moduleInfo.relativeName).account.minis[sceneShort];\n    if (!config.appID || !config.appSecret) return null;\n    return {\n      meta: {\n        title: sceneInfo.title,\n        mode: 'direct',\n        disableAssociate: true,\n      },\n      config: {},\n      handler: null,\n    };\n  }\n\n  const metaAuth = {\n    providers: {},\n  };\n\n  // wechat/wechatweb\n  for (const scene of ['wechat', 'wechatweb']) {\n    const sceneInfo = authProviderScenes.getScene(scene);\n    metaAuth.providers[sceneInfo.authProvider] = _createProvider(sceneInfo);\n  }\n\n  // minis\n  const minis = ctx.config.module(moduleInfo.relativeName).account.minis;\n  for (const sceneShort in minis) {\n    const scene = `wechatmini${sceneShort}`;\n    const sceneInfo = authProviderScenes.getScene(scene);\n    metaAuth.providers[sceneInfo.authProvider] = _createProviderMini(sceneInfo, sceneShort);\n  }\n\n  // ok\n  return metaAuth;\n};\n","module.exports = app => {\n  const routes = [\n    // message\n    { method: 'get', path: 'message/index', controller: 'message', meta: { auth: { enable: false } } },\n    { method: 'post', path: 'message/index', controller: 'message', meta: { auth: { enable: false } } },\n    // jsapi\n    { method: 'post', path: 'jssdk/jsconfig', controller: 'jssdk' },\n\n    // messageMini\n    { method: 'get', path: 'messageMini/:scene', controller: 'messageMini', action: 'index', meta: { auth: { enable: false } } },\n    { method: 'post', path: 'messageMini/:scene', controller: 'messageMini', action: 'index', meta: { auth: { enable: false } } },\n    // authMini\n    { method: 'post', path: 'authMini/login', controller: 'authMini' },\n  ];\n  return routes;\n};\n","const WechatHelperFn = require('../common/wechatHelper.js');\n\nmodule.exports = app => {\n  class AuthMini extends app.Service {\n    async login({ scene, code, detail }) {\n      let session_key;\n      let openid;\n      let unionid;\n\n      // mini\n      const apiMini = this.ctx.bean.wechat.mini[scene];\n\n      // code\n      if (code) {\n        // code2Session\n        const res = await apiMini.code2Session(code);\n        session_key = res.session_key;\n        openid = res.openid;\n        unionid = res.unionid;\n      } else {\n        // from cache\n        session_key = await apiMini.getSessionKey();\n      }\n      // openid/unionid\n      if ((!openid || !unionid) && detail && detail.encryptedData) {\n        const res = await apiMini.decryptMini(detail.encryptedData, detail.iv, session_key);\n        openid = res.openId;\n        unionid = res.unionId;\n      }\n      // check openid\n      if (!openid) this.ctx.throw(403);\n      // userInfo\n      const userInfo = { openid, unionid };\n      if (detail && detail.userInfo) {\n        userInfo.nickname = detail.userInfo.nickName;\n        userInfo.sex = detail.userInfo.gender;\n        userInfo.language = detail.userInfo.language;\n        userInfo.city = detail.userInfo.city;\n        userInfo.province = detail.userInfo.province;\n        userInfo.country = detail.userInfo.country;\n        userInfo.headimgurl = detail.userInfo.avatarUrl;\n      }\n      // verify\n      const wechatHelper = new (WechatHelperFn(this.ctx))();\n      await wechatHelper.verifyAuthUser({ scene: `wechatmini${scene}`, openid, userInfo });\n      // save session_key, because ctx.state.user maybe changed\n      await apiMini.saveSessionKey(session_key);\n      // echo\n      return await this.ctx.bean.auth.echo();\n    }\n  }\n\n  return AuthMini;\n};\n","module.exports = app => {\n  class JSSDK extends app.Service {\n    async jsconfig({ url }) {\n      // config\n      const config = this.ctx.config.account.public;\n      // params\n      const params = {\n        debug: config.jssdk.debug,\n        jsApiList: config.jssdk.jsApiList,\n        url,\n      };\n      return await this.ctx.bean.wechat.app.getJsConfig(params);\n    }\n  }\n\n  return JSSDK;\n};\n","const WechatHelperFn = require('../common/wechatHelper.js');\n\nmodule.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class Message extends app.Service {\n    async index({ message }) {\n      let result;\n      // event: subscribe\n      if (message.MsgType === 'event') {\n        if (message.Event === 'subscribe') {\n          result = await this._subscribeUser({ openid: message.FromUserName, message });\n        } else if (message.Event === 'unsubscribe') {\n          result = await this._unsubscribeUser({ openid: message.FromUserName, message });\n        }\n      }\n      // raise event\n      return await this.ctx.bean.event.invoke({\n        module: moduleInfo.relativeName,\n        name: 'wechatMessage',\n        data: { message },\n        result,\n        next: async (context, next) => {\n          // default\n          if (context.result === undefined) {\n            context.result = {\n              ToUserName: message.FromUserName,\n              FromUserName: message.ToUserName,\n              CreateTime: new Date().getTime(),\n              MsgType: 'text',\n              Content: this.ctx.config.account.public.message.reply.default,\n            };\n          }\n          await next();\n        },\n      });\n    }\n\n    async _subscribeUser({ openid, message }) {\n      // user info\n      const userInfo = await this.ctx.bean.wechat.app.getUser({ openid });\n      // verify auth user\n      const wechatHelper = new (WechatHelperFn(this.ctx))();\n      await wechatHelper.verifyAuthUser({ scene: 'wechat', openid, userInfo });\n      // ok\n      return {\n        ToUserName: message.FromUserName,\n        FromUserName: message.ToUserName,\n        CreateTime: new Date().getTime(),\n        MsgType: 'text',\n        Content: this.ctx.config.account.public.message.reply.subscribe,\n      };\n    }\n\n    async _unsubscribeUser({ openid, message }) {\n      // wechat user\n      const userWechat = await this.ctx.model.wechatUser.get({ openid });\n      if (userWechat) {\n        await this.ctx.model.wechatUser.update({\n          id: userWechat.id,\n          subscribe: 0,\n        });\n      }\n      // ok\n      return {\n        ToUserName: message.FromUserName,\n        FromUserName: message.ToUserName,\n        CreateTime: new Date().getTime(),\n        MsgType: 'text',\n        Content: '',\n      };\n    }\n  }\n\n  return Message;\n};\n","module.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class Message extends app.Service {\n    async index({ scene, message }) {\n      // raise event\n      await this.ctx.bean.event.invoke({\n        module: moduleInfo.relativeName,\n        name: 'wechatMessageMini',\n        data: { scene, message },\n      });\n    }\n  }\n\n  return Message;\n};\n","const message = require('./service/message.js');\nconst jssdk = require('./service/jssdk.js');\nconst messageMini = require('./service/messageMini.js');\nconst authMini = require('./service/authMini.js');\n\nmodule.exports = app => {\n  const services = {\n    message,\n    jssdk,\n    messageMini,\n    authMini,\n  };\n  return services;\n};\n","module.exports = require(\"crypto\");","module.exports = require(\"require3\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(421);\n"],"sourceRoot":""}